<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Dynamic</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Scripting.Actions.ActionBinder">
            <summary>
            Provides binding semantics for a language.  This include conversions as well as support
            for producing rules for actions.  These optimized rules are used for calling methods, 
            performing operators, and getting members using the ActionBinder's conversion semantics.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.ActionBinder.PrivateBinding">
            <summary>
            Determines if the binder should allow access to non-public members.
            
            By default the binder does not allow access to non-public members.  Base classes
            can inherit and override this value to customize whether or not private binding
            is available.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.Convert(System.Object,System.Type)">
            <summary>
            Converts an object at runtime into the specified type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.CanConvertFrom(System.Type,System.Type,System.Boolean,Microsoft.Scripting.Actions.Calls.NarrowingLevel)">
            <summary>
            Determines if a conversion exists from fromType to toType at the specified narrowing level.
            toNotNullable is true if the target variable doesn't allow null values.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.PreferConvert(System.Type,System.Type)">
            <summary>
            Provides ordering for two parameter types if there is no conversion between the two parameter types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.ConvertExpression(System.Linq.Expressions.Expression,System.Type,Microsoft.Scripting.Actions.ConversionResultKind,Microsoft.Scripting.Actions.Calls.OverloadResolverFactory)">
            <summary>
            Converts the provided expression to the given type.  The expression is safe to evaluate multiple times.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.GetMember(Microsoft.Scripting.Actions.MemberRequestKind,System.Type,System.String)">
            <summary>
            Gets the members that are visible from the provided type of the specified name.
            
            The default implemetnation first searches the type, then the flattened heirachy of the type, and then
            registered extension methods.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.MakeStaticAssignFromDerivedTypeError(System.Type,System.Dynamic.DynamicMetaObject,Microsoft.Scripting.Actions.MemberTracker,System.Dynamic.DynamicMetaObject,Microsoft.Scripting.Actions.Calls.OverloadResolverFactory)">
            <summary>
            Called when a set is attempting to assign to a field or property from a derived class through the base class.
            
            The default behavior is to allow the assignment.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.MakeStaticPropertyInstanceAccessError(Microsoft.Scripting.Actions.PropertyTracker,System.Boolean,System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject})">
            <summary>
            Creates an ErrorInfo object when a static property is accessed from an instance member.  The default behavior is throw
            an exception indicating that static members properties be accessed via an instance.  Languages can override this to 
            customize the exception, message, or to produce an ErrorInfo object which reads or writes to the property being accessed.
            </summary>
            <param name="tracker">The static property being accessed through an instance</param>
            <param name="isAssignment">True if the user is assigning to the property, false if the user is reading from the property</param>
            <param name="parameters">The parameters being used to access the property.  This includes the instance as the first entry, any index parameters, and the
            value being assigned as the last entry if isAssignment is true.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.MakeMissingMemberError(System.Type,System.Dynamic.DynamicMetaObject,System.String)">
            <summary>
            Provides a way for the binder to provide a custom error message when lookup fails.  Just
            doing this for the time being until we get a more robust error return mechanism.
            
            Deprecated, use the non-generic version instead
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.GetAllExtensionMembers(System.Type,System.String)">
            <summary>
            Gets the extension members of the given name from the provided type.  Base classes are also
            searched for their extension members.  Once any of the types in the inheritance hierarchy
            provide an extension member the search is stopped.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.GetExtensionMembers(System.Type,System.String)">
            <summary>
            Gets the extension members of the given name from the provided type.  Subclasses of the
            type and their extension members are not searched.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ActionBinder.ReturnMemberTracker(System.Type,Microsoft.Scripting.Actions.MemberTracker)">
            <summary>
            Provides an opportunity for languages to replace all MemberTracker's with their own type.
            
            Alternatlely a language can expose MemberTracker's directly.
            </summary>
            <param name="memberTracker">The member which is being returned to the user.</param>
            <param name="type">Tthe type which the memberTrack was accessed from</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Argument">
            <summary>
            TODO: Alternatively, it should be sufficient to remember indices for this, list, dict and block.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ArgumentType">
            <summary>
            Convention for an individual argument at a callsite.
            
            Multiple different callsites can match against a single declaration. 
            Some argument kinds can be "unrolled" into multiple arguments, such as list and dictionary. 
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ArgumentType.Simple">
            <summary>
            Simple unnamed positional argument.
            In Python: foo(1,2,3) are all simple arguments.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ArgumentType.Named">
            <summary>
            Argument with associated name at the callsite
            In Python: foo(a=1)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ArgumentType.List">
            <summary>
            Argument containing a list of arguments. 
            In Python: foo(*(1,2*2,3))  would match 'def foo(a,b,c)' with 3 declared arguments such that (a,b,c)=(1,4,3).
                 it could also match 'def foo(*l)' with 1 declared argument such that l=(1,4,3)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ArgumentType.Dictionary">
            <summary>
            Argument containing a dictionary of named arguments.
            In Python: foo(**{'a':1, 'b':2})
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.CallSignature">
            <summary>
            Richly represents the signature of a callsite.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.CallSignature._infos">
            <summary>
            Array of additional meta information about the arguments, such as named arguments.
            Null for a simple signature that's just an expression list. eg: foo(a*b,c,d)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.CallSignature._argumentCount">
            <summary>
            Number of arguments in the signature.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.CallSignature.IsSimple">
            <summary>
            All arguments are unnamed and matched by position. 
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.CallSignature.HasKeywordArgument">
            <summary>
            True if the OldCallAction includes an ArgumentInfo of ArgumentKind.Dictionary or ArgumentKind.Named.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.CallSignature.GetProvidedPositionalArgumentCount">
            <summary>
            Gets the number of positional arguments the user provided at the call site.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ActualArguments.SplatIndex">
            <summary>
            Gets the index into _args array indicating the first post-splat argument or -1 of there are no splatted arguments.
            For call site f(a,b,*c,d) and preSplatLimit == 1 and postSplatLimit == 2
            args would be (a,b,c[0],c[n-2],c[n-1],d) with splat index 3, where n = c.Count.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ActualArguments.Count">
            <summary>
            The number of arguments not counting the collapsed ones.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ActualArguments.HiddenCount">
            <summary>
            Gets the number of hidden arguments (used for error reporting).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ActualArguments.VisibleCount">
            <summary>
            Gets the total number of visible arguments passed to the call site including collapsed ones.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.ActualArguments.TryBindNamedArguments(Microsoft.Scripting.Actions.Calls.MethodCandidate,Microsoft.Scripting.Actions.Calls.ArgumentBinding@,Microsoft.Scripting.Actions.Calls.CallFailure@)">
            <summary>
            Binds named arguments to the parameters. Returns a permutation of indices that captures the relationship between 
            named arguments and their corresponding parameters. Checks for duplicate and unbound named arguments.
            Ensures that for all i: namedArgs[i] binds to parameters[args.Length + bindingPermutation[i]] 
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ArgBuilder">
            <summary>
            ArgBuilder provides an argument value used by the MethodBinder.  One ArgBuilder exists for each
            physical parameter defined on a method.  
            
            Contrast this with ParameterWrapper which represents the logical argument passed to the method.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ArgBuilder.Priority">
            <summary>
            Gets the priority.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ArgBuilder.ConsumedArgumentCount">
            <summary>
            The number of actual arguments consumed by this builder.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.ArgBuilder.ToExpression(Microsoft.Scripting.Actions.Calls.OverloadResolver,Microsoft.Scripting.Actions.Calls.RestrictedArguments,System.Boolean[])">
            <summary>
            Provides the Expression which provides the value to be passed to the argument.
            If <c>null</c> is returned the argument is skipped (not passed to the callee).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ArgBuilder.Type">
            <summary>
            Returns the type required for the argument or null if the ArgBuilder
            does not consume a type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.ArgBuilder.UpdateFromReturn(Microsoft.Scripting.Actions.Calls.OverloadResolver,Microsoft.Scripting.Actions.Calls.RestrictedArguments)">
            <summary>
            Provides an Expression which will update the provided value after a call to the method.  May
            return null if no update is required.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.ArgBuilder.ToReturnExpression(Microsoft.Scripting.Actions.Calls.OverloadResolver)">
            <summary>
            If the argument produces a return value (e.g. a ref or out value) this provides
            the additional value to be returned.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ArgBuilder.ByRefArgument">
            <summary>
            An assignable value that is passed to a byref parameter
            After the call it will contain the updated value
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.BindingResult">
            <summary>
            Indicates the specific type of failure, if any, from binding to a method.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.BindingResult.Success">
            <summary>
            The binding succeeded.  Only one method was applicable or had the best conversion.  
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.BindingResult.AmbiguousMatch">
            <summary>
            More than one method was applicable for the provided parameters and no method was considered the best.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.BindingResult.IncorrectArgumentCount">
            <summary>
            There are no overloads that match the number of parameters required for the call
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.BindingResult.CallFailure">
            <summary>
            None of the target method(s) can successfully be called.  The failure can be due to:
                1. Arguments could not be successfully converted for the call
                2. Keyword arguments could not be assigned to positional arguments
                3. Keyword arguments could be assigned but would result in an argument being assigned 
                   multiple times (keyword and positional arguments conflit or dupliate keyword arguments).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.BindingResult.InvalidArguments">
            <summary>
            Actual arguments cannot be constructed.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.BindingResult.NoCallableMethod">
            <summary>
            No method is callable. For example, all methods have an unbound generic parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.BindingTarget">
            <summary>
            Encapsulates the result of an attempt to bind to one or methods using the OverloadResolver.
            
            Users should first check the Result property to see if the binding was successful or
            to determine the specific type of failure that occured.  If the binding was successful
            MakeExpression can then be called to create an expression which calls the method.
            If the binding was a failure callers can then create a custom error message based upon
            the reason the call failed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.#ctor(System.String,System.Int32,Microsoft.Scripting.Actions.Calls.MethodCandidate,Microsoft.Scripting.Actions.Calls.NarrowingLevel,Microsoft.Scripting.Actions.Calls.RestrictedArguments)">
            <summary>
            Creates a new BindingTarget when the method binding has succeeded.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.#ctor(System.String,System.Int32,System.Int32[])">
            <summary>
            Creates a new BindingTarget when the method binding has failed due to an incorrect argument count
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.#ctor(System.String,System.Int32,Microsoft.Scripting.Actions.Calls.CallFailure[])">
            <summary>
            Creates a new BindingTarget when the method binding has failued due to 
            one or more parameters which could not be converted.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.#ctor(System.String,System.Int32,Microsoft.Scripting.Actions.Calls.MethodCandidate[])">
            <summary>
            Creates a new BindingTarget when the match was ambiguous
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.#ctor(System.String,Microsoft.Scripting.Actions.Calls.BindingResult)">
            <summary>
            Other failure.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.Result">
            <summary>
            Gets the result of the attempt to bind.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.BindingTarget.MakeExpression">
            <summary>
            Gets an Expression which calls the binding target if the method binding succeeded.
            
            Throws InvalidOperationException if the binding failed.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.Method">
            <summary>
            Returns the method if the binding succeeded, or null if no method was applicable.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.Overload">
            <summary>
            Returns the selected overload if the binding succeeded, or null if no one was applicable.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.Name">
            <summary>
            Gets the name of the method as supplied to the OverloadResolver.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.MethodCandidate">
            <summary>
            Returns the MethodTarget if the binding succeeded, or null if no method was applicable.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.AmbiguousMatches">
            <summary>
            Returns the methods which don't have any matches or null if Result == BindingResult.AmbiguousMatch
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.CallFailures">
            <summary>
            Returns the methods and their associated conversion failures if Result == BindingResult.CallFailure.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.ExpectedArgumentCount">
            <summary>
            Returns the acceptable number of arguments which can be passed to the method if Result == BindingResult.IncorrectArgumentCount.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.ActualArgumentCount">
            <summary>
            Returns the total number of arguments provided to the call. 0 if the call succeeded or failed for a reason other
            than argument count mismatch.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.RestrictedArguments">
            <summary>
            Gets the MetaObjects which we originally did binding against in their restricted form.
            
            The members of the array correspond to each of the arguments.  All members of the array
            have a value.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.ReturnType">
            <summary>
            Returns the return type of the binding, or null if no method was applicable.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.NarrowingLevel">
            <summary>
            Gets the NarrowingLevel of the method if the call succeeded.
            If the call failed returns NarrowingLevel.None.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.BindingTarget.Success">
            <summary>
            Returns true if the binding was succesful, false if it failed.
            This is an alias for BindingTarget.Result == BindingResult.Success.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.CallFailure">
            <summary>
            Represents the reason why a call to a specific method could not be performed by the OverloadResolver.
            
            The reason for the failure is specified by the CallFailureReason property.  Once this property
            has been consulted the other properties can be consulted for more detailed information regarding
            the failure.
            
            If reason is ConversionFailure the ConversionResults property will be non-null.
            If reason is UnassignableKeyword the KeywordArguments property will be non-null and include
                the keywords which could not be assigned.
            If reason is DuplicateKeyword the KeywordArguments property will be non-null and include
                the keywords which were duplicated (either by the keywords themselves or by positional
                arguments).
                
            MethodTarget is always set and indicates the method which failed to bind.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.CallFailure.Candidate">
            <summary>
            Gets the MethodTarget which the call failed for.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.CallFailure.Reason">
            <summary>
            Gets the reason for the call failure which determines the other 
            properties of the CallFailure which should be consulted.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.CallFailure.ConversionResults">
            <summary>
            Gets a list of ConversionResult's for each parameter indicating
            whether the conversion was successful or failed and the types
            being converted.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.CallFailure.KeywordArguments">
            <summary>
            Gets the list of keyword arguments that were either dupliated or
            unassignable.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.CallFailureReason.None">
            <summary>
            Default value, their was no CallFailure.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.CallFailureReason.ConversionFailure">
            <summary>
            One of more parameters failed to be converted
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.CallFailureReason.UnassignableKeyword">
            <summary>
            One or more keyword arguments could not be successfully assigned to a positional argument
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.CallFailureReason.DuplicateKeyword">
            <summary>
            One or more keyword arguments were duplicated or would have taken the spot of a 
            provided positional argument.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.CallFailureReason.TypeInference">
            <summary>
            Type arguments could not be inferred
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.CandidateSet">
            <summary>
            Represents a collection of MethodCandidate's which all accept the
            same number of logical parameters.  For example a params method
            and a method with 3 parameters would both be a CandidateSet for 3 parameters.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ConversionResult">
            <summary>
            Represents information about a failure to convert an argument from one
            type to another.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ConversionResult.Arg">
            <summary>
            Value of the argument or null if it is not available.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ConversionResult.ArgType">
            <summary>
            Argument actual type or its limit type if the value not known.
            DynamicNull if the argument value is null.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.DefaultArgBuilder">
            <summary>
            ArgBuilder which provides a default parameter value for a method call.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.InstanceBuilder.ConsumedArgumentCount">
            <summary>
            The number of actual arguments consumed by this builder.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.KeywordArgBuilder">
            <summary>
            ArgBuilder which provides a value for a keyword argument.  
            
            The KeywordArgBuilder calculates its position at emit time using it's initial 
            offset within the keyword arguments, the number of keyword arguments, and the 
            total number of arguments provided by the user.  It then delegates to an 
            underlying ArgBuilder which only receives the single correct argument.
            
            Delaying the calculation of the position to emit time allows the method binding to be 
            done without knowing the exact the number of arguments provided by the user. Hence,
            the method binder can be dependent only on the set of method overloads and keyword names,
            but not the user arguments. While the number of user arguments could be determined
            upfront, the current MethodBinder does not have this design.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.KeywordArgBuilder.BuilderExpectsSingleParameter(Microsoft.Scripting.Actions.Calls.ArgBuilder)">
            <summary>
            The underlying builder should expect a single parameter as KeywordArgBuilder is responsible
            for calculating the correct parameter to use
            </summary>
            <param name="builder"></param>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.KeywordConstructorReturnBuilder">
            <summary>
            Updates fields/properties of the returned value with unused keyword parameters.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.MethodCandidate">
             <summary>
             MethodCandidate represents the different possible ways of calling a method or a set of method overloads.
             A single method can result in multiple MethodCandidates. Some reasons include:
             - Every optional parameter or parameter with a default value will result in a candidate
             - The presence of ref and out parameters will add a candidate for languages which want to return the updated values as return values.
             - ArgumentKind.List and ArgumentKind.Dictionary can result in a new candidate per invocation since the list might be different every time.
            
             Each MethodCandidate represents the parameter type for the candidate using ParameterWrapper.
             </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.MethodCandidate.MakeParamsExtended(System.Int32,System.Collections.Generic.IList{System.String})">
            <summary>
            Builds a new MethodCandidate which takes count arguments and the provided list of keyword arguments.
            
            The basic idea here is to figure out which parameters map to params or a dictionary params and
            fill in those spots w/ extra ParameterWrapper's.  
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.NarrowingLevel">
            <summary>
            Narrowing conversions are conversions that cannot be proved to always succeed, conversions that are 
            known to possibly lose information, and conversions across domains of types sufficiently different 
            to merit narrowing notation like casts. 
            
            Its upto every language to define the levels for conversions. The narrowling levels can be used by
            for method overload resolution, where the overload is based on the parameter types (and not the number 
            of parameters).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.NarrowingLevel.None">
            <summary>
            Conversions at this level do not do any narrowing. Typically, this will include
            implicit numeric conversions, Type.IsAssignableFrom, StringBuilder to string, etc.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.NarrowingLevel.One">
            <summary>
            Language defined prefered narrowing conversion.  First level that introduces narrowing
            conversions.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.NarrowingLevel.Two">
            <summary>
            Language defined preferred narrowing conversion.  Second level that introduces narrowing
            conversions and should have more conversions than One.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.NarrowingLevel.Three">
            <summary>
            Language defined preferred narrowing conversion.  Third level that introduces narrowing
            conversions and should have more conversions that Two.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.Calls.NarrowingLevel.All">
            <summary>
            A somewhat meaningful conversion is possible, but it will quite likely be lossy.
            For eg. BigInteger to an Int32, Boolean to Int32, one-char string to a char,
            larger number type to a smaller numeric type (where there is no overflow), etc
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.OutArgBuilder">
            <summary>
            Builds the argument for an out argument when not passed a StrongBox.  The out parameter
            is returned as an additional return value.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.OverloadInfo">
            <summary>
            Defines a method overload abstraction for the purpose of overload resolution. 
            It provides the overload resolver the metadata it needs to perform the resolution.
            </summary>
            <remarks>
            WARNING: This is a temporary API that will undergo breaking changes in future versions.
            </remarks>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.OverloadInfo.ReturnParameter">
            <summary>
            Null for constructors.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.OverloadInfo.IsVariadic">
            <summary>
            The method arity can vary, i.e. the method has params array or params dict parameters.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ReflectionOverloadInfo">
            <summary>
            Represents a method overload that is bound to a <see cref="T:System.Reflection.MethodBase"/>.
            </summary>
            <remarks>
            Not thread safe.
            WARNING: This is a temporary API that will undergo breaking changes in future versions. 
            </remarks>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.OverloadResolver">
            <summary>
            Provides binding and overload resolution to .NET methods.
            
            MethodBinder's can be used for:
                generating new AST code for calling a method 
                calling a method via reflection at runtime
                (not implemented) performing an abstract call
                
            MethodBinder's support default arguments, optional arguments, by-ref (in and out), and keyword arguments.
            
            Implementation Details:
            
            The MethodBinder works by building up a CandidateSet for each number of effective arguments that can be
            passed to a set of overloads.  For example a set of overloads such as:
                foo(object a, object b, object c)
                foo(int a, int b)
                
            would have 2 target sets - one for 3 parameters and one for 2 parameters.  For parameter arrays
            we fallback and create the appropriately sized CandidateSet on demand.
            
            Each CandidateSet consists of a set of MethodCandidate's.  Each MethodCandidate knows the flattened
            parameters that could be received.  For example for a function such as:
                foo(params int[] args)
                
            When this method is in a CandidateSet of size 3 the MethodCandidate takes 3 parameters - all of them
            ints; if it's in a CandidateSet of size 4 it takes 4 parameters.  Effectively a MethodCandidate is 
            a simplified view that allows all arguments to be treated as required positional arguments.
            
            Each MethodCandidate in turn refers to a MethodTarget.  The MethodTarget is composed of a set
            of ArgBuilder's and a ReturnBuilder which know how to consume the positional arguments and pass
            them to the appropriate argument of the destination method.  This includes routing keyword
            arguments to the correct position, providing the default values for optional arguments, etc...
            
            After binding is finished the MethodCandidates are thrown away and a BindingTarget is returned. 
            The BindingTarget indicates whether the binding was successful and if not any additional information
            that should be reported to the user about the failed binding.  It also exposes the MethodTarget which
            allows consumers to get the flattened list of required parameters for the call.  MethodCandidates
            are not exposed and are an internal implementation detail of the MethodBinder.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.OverloadResolver.ResolveOverload(System.String,System.Collections.Generic.IList{System.Reflection.MethodBase},Microsoft.Scripting.Actions.Calls.NarrowingLevel,Microsoft.Scripting.Actions.Calls.NarrowingLevel)">
            <summary>
            Resolves a method overload and returns back a BindingTarget.
            
            The BindingTarget can then be tested for the success or particular type of
            failure that prevents the method from being called. If successfully bound the BindingTarget
            contains a list of argument meta-objects with additional restrictions that ensure the selection
            of the particular overload.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.OverloadResolver.AllowMemberInitialization(Microsoft.Scripting.Actions.Calls.OverloadInfo)">
            <summary>
            Checks to see if the language allows named arguments to be bound to instance fields or
            properties and turned into setters. By default this is only allowed on contructors.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.OverloadResolver.GetByRefArrayExpression(System.Linq.Expressions.Expression)">
            <summary>
            Gets an expression that evaluates to the result of GetByRefArray operation.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.OverloadResolver.BindToUnexpandedParams(Microsoft.Scripting.Actions.Calls.MethodCandidate)">
            <summary>
            Allow to bind an array/dictionary instance or a null reference to params array/dictionary parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.OverloadResolver.MapSpecialParameters(Microsoft.Scripting.Actions.Calls.ParameterMapping)">
            <summary>
            Called before arguments binding.
            </summary>
            <returns>
            A bitmask that indicates (set bits) the parameters that were mapped by this method.
            A default mapping will be constructed for the remaining parameters (cleared bits).
            </returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.OverloadResolver.CreateActualArguments(System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject},System.Collections.Generic.IList{System.String},System.Int32,System.Int32)">
            <summary>
            Return null if arguments cannot be constructed and overload resolution should produce an error.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.OverloadResolver.IsOverloadedOnParameter(System.Int32,System.Int32,System.Collections.Generic.IList{Microsoft.Scripting.Actions.Calls.ApplicableCandidate})">
            <summary>
            Determines whether given overloads are overloaded on index-th parameter (the types of the index-th parameters are the same).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.OverloadResolver.SelectBestConversionFor(System.Dynamic.DynamicMetaObject,Microsoft.Scripting.Actions.Calls.ParameterWrapper,Microsoft.Scripting.Actions.Calls.ParameterWrapper,Microsoft.Scripting.Actions.Calls.NarrowingLevel)">
            <summary>
            Selects the best (of two) candidates for conversion from actualType
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.OverloadResolver.PreferConvert(System.Type,System.Type)">
            <summary>
            Provides ordering for two parameter types if there is no conversion between the two parameter types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.OverloadResolver.GetSplattedItemExpression(System.Linq.Expressions.Expression)">
            <summary>
            The method is called each time an item of lazily splatted argument is needed.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ParameterMapping.ArgIndex">
            <summary>
            Gets the next argument to consume.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.ParameterMapping.MapParameterReduceByRef(System.Reflection.ParameterInfo)">
            <summary>
            Maps out parameters to return args and ref parameters to ones that don't accept StrongBox.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ParameterWrapper">
            <summary>
            ParameterWrapper represents the logical view of a parameter. For eg. the byref-reduced signature
            of a method with byref parameters will be represented using a ParameterWrapper of the underlying
            element type, since the logical view of the byref-reduced signature is that the argument will be
            passed by value (and the updated value is included in the return value).
            
            Contrast this with ArgBuilder which represents the real physical argument passed to the method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.ParameterWrapper.#ctor(System.Type,System.String,System.Boolean)">
            <summary>
            ParameterInfo is not available.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ParameterWrapper.IsParamsArray">
            <summary>
            True if the wrapper represents a params-array parameter (false for parameters created by expansion of a params-array).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.ParameterWrapper.IsParamsDict">
            <summary>
            True if the wrapper represents a params-dict parameter (false for parameters created by expansion of a params-dict).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.ParameterWrapper.Expand">
            <summary>
            Creates a parameter that represents an expanded item of params-array.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ParamsDictArgBuilder">
            <summary>
            Builds the parameter for a params dictionary argument - this collects all the extra name/value
            pairs provided to the function into a SymbolDictionary which is passed to the function.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ReferenceArgBuilder">
            <summary>
            An argument that the user wants to explicitly pass by-reference (with copy-in copy-out semantics).
            The user passes a StrongBox[T] object whose value will get updated when the call returns.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.RestrictedArguments.HasUntypedRestrictions">
            <summary>
            True if there are restrictions beyond just simple type restrictions
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.ReturnBuilder.#ctor(System.Type)">
            <summary>
            Creates a ReturnBuilder
            </summary>
            <param name="returnType">the type the ReturnBuilder will leave on the stack</param>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.ReturnReferenceArgBuilder">
            <summary>
            Builds a parameter for a reference argument when a StrongBox has not been provided.  The
            updated return value is returned as one of the resulting return values.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.SimpleArgBuilder">
            <summary>
            SimpleArgBuilder produces the value produced by the user as the argument value.  It
            also tracks information about the original parameter and is used to create extended
            methods for params arrays and param dictionary functions.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.SimpleArgBuilder.#ctor(System.Type,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Parameter info is not available for this argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.SimpleArgBuilder.#ctor(System.Reflection.ParameterInfo,System.Int32)">
            <summary>
            Type and whether the parameter is a params-array or params-dictionary is derived from info.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.Calls.SimpleArgBuilder.Index">
            <summary>
            Gets the index of actual argument expression.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.GetGenericArgumentsForInferedMethod(Microsoft.Scripting.Actions.Calls.OverloadInfo,System.Collections.Generic.Dictionary{System.Type,System.Type})">
            <summary>
            Gets the generic arguments for method based upon the constraints discovered during
            type inference.  Returns null if not all generic arguments had their types inferred.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.CreateNewArgBuilders(Microsoft.Scripting.Actions.Calls.MethodCandidate,Microsoft.Scripting.Actions.Calls.OverloadInfo)">
            <summary>
            Creates a new set of arg builders for the given generic method definition which target the new
            parameters.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.CreateNewWrappers(Microsoft.Scripting.Actions.Calls.MethodCandidate,Microsoft.Scripting.Actions.Calls.OverloadInfo,Microsoft.Scripting.Actions.Calls.OverloadInfo)">
            <summary>
            Creates a new list of ParameterWrappers for the generic method replacing the old parameters with the new ones.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.GetSortedGenericArguments(Microsoft.Scripting.Actions.Calls.OverloadInfo,System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.List{System.Type}})">
            <summary>
            Gets the generic type arguments sorted so that the type arguments
            that are depended upon by other type arguments are sorted before
            their dependencies.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.IsDependentConstraint(System.Collections.Generic.Dictionary{System.Type,System.Collections.Generic.List{System.Type}},System.Type,System.Type)">
            <summary>
            Checks to see if the x type parameter is dependent upon the y type parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.GetDependencyMapping(Microsoft.Scripting.Actions.Calls.OverloadInfo)">
            <summary>
            Builds a mapping based upon generic parameter constraints between related generic
            parameters.  This is then used to sort the generic parameters so that we can process
            the least dependent parameters first.  For example given the method:
            
            void Foo{T0, T1}(T0 x, T1 y) where T0 : T1 
            
            We need to first infer the type information for T1 before we infer the type information
            for T0 so that we can ensure the constraints are correct.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.GetArgumentToInputMapping(Microsoft.Scripting.Actions.Calls.MethodCandidate,System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject})">
            <summary>
            Returns a mapping from generic type parameter to the input DMOs which map to it.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.AddOneInput(System.Collections.Generic.Dictionary{System.Type,Microsoft.Scripting.Actions.Calls.TypeInferer.ArgumentInputs},System.Dynamic.DynamicMetaObject,System.Type)">
            <summary>
            Adds any additional ArgumentInputs entries for the given object and parameter type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.CollectGenericParameters(System.Type,System.Collections.Generic.List{System.Type})">
            <summary>
            Walks the nested generic hierarchy to construct all of the generic parameters referred
            to by this type.  For example if getting the generic parameters for the x parameter on
            the method:
            
            void Foo{T0, T1}(Dictionary{T0, T1} x);
            
            We would add both typeof(T0) and typeof(T1) to the list of generic arguments.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.TypeInferer.ArgumentInputs">
            <summary>
            Maps a single type parameter to the possible parameters and DynamicMetaObjects
            we can get inference from.  For example for the signature:
            
            void Foo{T0, T1}(T0 x, T1 y, IList{T1} z);
            
            We would have one ArgumentInput for T0 which holds onto the DMO providing the argument
            value for x.  We would also have one ArgumentInput for T1 which holds onto the 2 DMOs
            for y and z.  Associated with y would be a GenericParameterInferer and associated with
            z would be a ConstructedParameterInferer.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.GetInferedType(Microsoft.Scripting.Actions.Calls.OverloadResolver,System.Type,System.Type,System.Dynamic.DynamicMetaObject,System.Collections.Generic.Dictionary{System.Type,System.Type},System.Collections.Generic.Dictionary{System.Dynamic.DynamicMetaObject,System.Dynamic.BindingRestrictions})">
            <summary>
            Provides generic type inference for a single parameter.
            </summary>
            <remarks>
            For example: 
              M{T}(T x)
              M{T}(IList{T} x)
              M{T}(ref T x)
              M{T}(T[] x)
              M{T}(ref Dictionary{T,T}[] x)
            </remarks>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.GetInferedType(System.Type,System.Type,System.Type,System.Type,System.Collections.Generic.Dictionary{System.Type,System.Type})">
            <summary>
            Provides generic type inference for a single parameter.
            </summary>
            <remarks>
            For example: 
              M{T}(T x)
              M{T}(IList{T} x)
              M{T}(ref T x)
              M{T}(T[] x)
              M{T}(ref Dictionary{T,T}[] x)
            </remarks>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.ConstraintsViolated(System.Type,System.Type,System.Collections.Generic.Dictionary{System.Type,System.Type})">
            <summary>
            Checks if the constraints are violated by the given input for the specified generic method parameter.
            
            This method must be supplied with a mapping for any dependent generic method type parameters which
            this one can be constrained to.  For example for the signature "void Foo{T0, T1}(T0 x, T1 y) where T0 : T1".
            we cannot know if the constraints are violated unless we know what we have calculated T1 to be.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.TypeInferer.MatchGenericParameter(System.Type,System.Type,System.Type,System.Collections.Generic.Dictionary{System.Type,System.Type},System.Type@)">
            <summary>
            Finds all occurences of <c>genericParameter</c> in <c>openType</c> and the corresponding concrete types in <c>closedType</c>.
            Returns true iff all occurences of the generic parameter in the open type correspond to the same concrete type in the closed type 
            and this type satisfies given <c>constraints</c>. Returns the concrete type in <c>match</c> if so.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.IInferableInvokable">
            <summary>
            Implemented by DynamicMetaObject subclasses when the associated object
            can participate in generic method type inference.  This interface
            is used when the inference engine is attempting to perform type inference
            for a parameter which is typed to a delegate type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.Calls.IInferableInvokable.GetInferredType(System.Type,System.Type)">
            <summary>
            Returns the type inferred for parameterType when performing
            inference for a conversion to delegateType.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Calls.InferenceResult">
            <summary>
            Provides information about the result of a custom object which dynamically infers back types.
            Currently only used for invokable objects to feedback the types for a delegate type.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComboActionRewriter">
            <summary>
            A tree rewriter which will find dynamic sites which consume dynamic sites and
            turn them into a single combo dynamic site.  The combo dynamic site will then run the
            individual meta binders and produce the resulting code in a single dynamic site.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComboActionRewriter.ComboDynamicSiteExpression">
            <summary>
            A reducible node which we use to generate the combo dynamic sites.  Each time we encounter
            a dynamic site we replace it with a ComboDynamicSiteExpression.  When a child of a dynamic site
            turns out to be a ComboDynamicSiteExpression we will then merge the child with the parent updating
            the binding mapping info.  If any of the inputs cause side effects then we'll stop the combination.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ComboBinder">
            <summary>
            A binder which can combine multiple binders into a single dynamic site.  The creator
            of this needs to perform the mapping of parameters, constants, and sub-site expressions
            and provide a List of BinderMappingInfo representing this data.  From there the ComboBinder
            just processes the list to create the resulting code.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ParameterMappingInfo">
            <summary>
            Provides a mapping for inputs of combo action expressions.  The input can map
            to either an input of the new dynamic site, an input of a previous DynamicExpression,
            or a ConstantExpression which has been pulled out of the dynamic site arguments.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.BinderMappingInfo">
            <summary>
            Contains the mapping information for a single Combo Binder.  This includes the original
            meta-binder and the mapping of parameters, sub-sites, and constants into the binding.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ConditionalBuilder">
            <summary>
            Builds up a series of conditionals when the False clause isn't yet known.  We can
            keep appending conditions and if true's.  Each subsequent true branch becomes the
            false branch of the previous condition and body.  Finally a non-conditional terminating
            branch must be added.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConditionalBuilder.AddCondition(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Adds a new conditional and body.  The first call this becomes the top-level
            conditional, subsequent calls will have it added as false statement of the
            previous conditional.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConditionalBuilder.FinishCondition(System.Linq.Expressions.Expression)">
            <summary>
            Adds the non-conditional terminating node.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConditionalBuilder.FinishError(System.Linq.Expressions.Expression)">
            <summary>
            Adds the non-conditional terminating node.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConditionalBuilder.GetMetaObject(System.Dynamic.DynamicMetaObject[])">
            <summary>
            Gets the resulting meta object for the full body.  FinishCondition
            must have been called.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ConditionalBuilder.AddVariable(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Adds a variable which will be scoped at the level of the final expression.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ConversionResultKind">
            <summary>
            Determines the result of a conversion action.  The result can either result in an exception, a value that
            has been successfully converted or default(T), or a true/false result indicating if the value can be converted.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ConversionResultKind.ImplicitCast">
            <summary>
            Attempts to perform available implicit conversions and throws if there are no available conversions.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ConversionResultKind.ExplicitCast">
            <summary>
            Attempst to perform available implicit and explicit conversions and throws if there are no available conversions.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ConversionResultKind.ImplicitTry">
            <summary>
            Attempts to perform available implicit conversions and returns default(ReturnType) if no conversions can be performed.
            
            If the return type of the rule is a value type then the return value will be zero-initialized.  If the return type
            of the rule is object or another class then the return type will be null (even if the conversion is to a value type).
            This enables ImplicitTry to be used to do TryConvertTo even if the type is value type (and the difference between
            null and a real value can be distinguished).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ConversionResultKind.ExplicitTry">
            <summary>
            Attempts to perform available implicit and explicit conversions and returns default(ReturnType) if no conversions 
            can be performed.
            
            If the return type of the rule is a value type then the return value will be zero-initialized.  If the return type
            of the rule is object or another class then the return type will be null (even if the conversion is to a value type).
            This enables ExplicitTry to be used to do TryConvertTo even if the type is value type (and the difference between
            null and a real value can be distinguished).
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.CustomTracker">
            <summary>
            A custom member tracker which enables languages to plug in arbitrary
            members into the lookup process.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DefaultBinder">
            <summary>
            Provides binding semantics for a language.  This include conversions as well as support
            for producing rules for actions.  These optimized rules are used for calling methods, 
            performing operators, and getting members using the ActionBinder's conversion semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryConvertToObject(System.Type,System.Type,System.Dynamic.DynamicMetaObject,System.Dynamic.BindingRestrictions)">
            <summary>
            Checks if the conversion is to object and produces a target if it is.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryAllConversions(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,System.Type,Microsoft.Scripting.Actions.ConversionResultKind,System.Type,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Checks if any conversions are available and if so builds the target for that conversion.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryAssignableConversion(System.Type,System.Type,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Checks if the conversion can be handled by a simple cast.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryUserDefinedConversion(Microsoft.Scripting.Actions.ConversionResultKind,System.Type,System.Type,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Checks if the conversion can be handled by calling a user-defined conversion method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryOneConversion(Microsoft.Scripting.Actions.ConversionResultKind,System.Type,System.Type,System.Type,System.String,System.Boolean,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper that checkes both types to see if either one defines the specified conversion
            method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryUserDefinedConversion(Microsoft.Scripting.Actions.ConversionResultKind,System.Type,System.Type,Microsoft.Scripting.Actions.MemberGroup,System.Boolean,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Checks if any of the members of the MemberGroup provide the applicable conversion and 
            if so uses it to build a conversion rule.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryExtensibleConversion(System.Type,System.Type,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Checks if the conversion is to applicable by extracting the value from Extensible of T.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryImplicitNumericConversion(System.Type,System.Type,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Checks if there's an implicit numeric conversion for primitive data types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryNullableConversion(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,System.Type,Microsoft.Scripting.Actions.ConversionResultKind,System.Type,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Checks if there's a conversion to/from Nullable of T.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryNullConversion(System.Type,System.Type,System.Dynamic.BindingRestrictions)">
            <summary>
            Checks to see if there's a conversion of null to a reference type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeErrorTarget(System.Type,Microsoft.Scripting.Actions.ConversionResultKind,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper to produce an error when a conversion cannot occur
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeBoxingTarget(System.Dynamic.DynamicMetaObject,System.Dynamic.BindingRestrictions)">
            <summary>
            Helper to produce a rule which just boxes a value type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeConversionTarget(Microsoft.Scripting.Actions.ConversionResultKind,Microsoft.Scripting.Actions.MethodTracker,System.Type,System.Boolean,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper to produce a conversion rule by calling the helper method to do the convert
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeExtensibleConversionTarget(Microsoft.Scripting.Actions.ConversionResultKind,Microsoft.Scripting.Actions.MethodTracker,System.Type,System.Boolean,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper to produce a conversion rule by calling the helper method to do the convert
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeConversionTargetWorker(Microsoft.Scripting.Actions.ConversionResultKind,Microsoft.Scripting.Actions.MethodTracker,System.Boolean,System.Dynamic.BindingRestrictions,System.Linq.Expressions.Expression)">
            <summary>
            Helper to produce a conversion rule by calling the method to do the convert.  This version takes the parameter
            to be passed to the conversion function and we call it w/ our own value or w/ our Extensible.Value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.WrapForThrowingTry(Microsoft.Scripting.Actions.ConversionResultKind,System.Boolean,System.Linq.Expressions.Expression,System.Type)">
            <summary>
            Helper to wrap explicit conversion call into try/catch incase it throws an exception.  If
            it throws the default value is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeSimpleConversionTarget(System.Type,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper to produce a rule when no conversion is required (the strong type of the expression
            input matches the type we're converting to or has an implicit conversion at the IL level)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeSimpleExtensibleConversionTarget(System.Type,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper to produce a rule when no conversion is required from an extensible type's
            underlying storage to the type we're converting to.  The type of extensible type
            matches the type we're converting to or has an implicit conversion at the IL level.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeExtensibleTarget(System.Type,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper to extract the value from an Extensible of T
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeNullToNullableOfTTarget(System.Type,System.Dynamic.BindingRestrictions)">
            <summary>
            Helper to convert a null value to nullable of T
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeTToNullableOfTTarget(System.Type,System.Type,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper to produce the rule for converting T to Nullable of T
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeConvertingToTToNullableOfTTarget(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,System.Type,Microsoft.Scripting.Actions.ConversionResultKind,System.Dynamic.BindingRestrictions,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper to produce the rule for converting T to Nullable of T
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetTryConvertReturnValue(System.Type)">
            <summary>
            Returns a value which indicates failure when a OldConvertToAction of ImplicitTry or
            ExplicitTry.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetExtensibleValue(System.Type,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper to extract the Value of an Extensible of T from the
            expression being converted.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetUnderlyingType(System.Type)">
            <summary>
            Helper that checks if fromType is an Extensible of T or a subtype of 
            Extensible of T and if so returns the T.  Otherwise it returns fromType.
            
            This is used to treat extensible types the same as their underlying types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeNullTarget(System.Type,System.Dynamic.BindingRestrictions)">
            <summary>
            Creates a target which returns null for a reference type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeUndeletableMemberError(System.Type,System.String)">
            <summary>
            Provides a way for the binder to provide a custom error message when lookup fails.  Just
            doing this for the time being until we get a more robust error return mechanism.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeNonPublicMemberGetError(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,Microsoft.Scripting.Actions.MemberTracker,System.Type,System.Dynamic.DynamicMetaObject)">
            <summary>
            Called when the user is accessing a protected or private member on a get.
            
            The default implementation allows access to the fields or properties using reflection.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeReadOnlyMemberError(System.Type,System.String)">
            <summary>
            Provides a way for the binder to provide a custom error message when lookup fails.  Just
            doing this for the time being until we get a more robust error return mechanism.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeOperatorDeleteMemberBody(Microsoft.Scripting.Actions.DefaultBinder.SetOrDeleteMemberInfo,System.Dynamic.DynamicMetaObject,System.Type,System.String)">
            <summary> if a member-injector is defined-on or registered-for this type call it </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DefaultBinder.SetOrDeleteMemberInfo">
            <summary>
            Helper class for flowing information about the GetMember request.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetMember(System.String,System.Dynamic.DynamicMetaObject)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
            <returns>
            Returns a DynamicMetaObject which represents the value that will be returned when the member is accessed.
            
            The returned DynamicMetaObject may be strongly typed to a value type which needs boxing before being
            returned from a standard DLR GetMemberBinder.  The language is responsible for performing any boxing
            so that it has an opportunity to perform custom boxing.
            </returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetMember(System.String,System.Dynamic.DynamicMetaObject,Microsoft.Scripting.Actions.Calls.OverloadResolverFactory)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
            <param name="resolverFactory">
            Provides overload resolution and method binding for any calls which need to be performed for the GetMember.
            </param>
            <returns>
            Returns a DynamicMetaObject which represents the value that will be returned when the member is accessed.
            
            The returned DynamicMetaObject may be strongly typed to a value type which needs boxing before being
            returned from a standard DLR GetMemberBinder.  The language is responsible for performing any boxing
            so that it has an opportunity to perform custom boxing.
            </returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetMember(System.String,System.Dynamic.DynamicMetaObject,Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,System.Boolean,System.Dynamic.DynamicMetaObject)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
            <param name="resolverFactory">
            An OverloadResolverFactory which can be used for performing overload resolution and method binding.
            </param>
            <param name="isNoThrow">
            True if the operation should return Operation.Failed on failure, false if it
            should return the exception produced by MakeMissingMemberError.
            </param>
            <param name="errorSuggestion">
            The meta object to be used if the get results in an error.
            </param>
            <returns>
            Returns a DynamicMetaObject which represents the value that will be returned when the member is accessed.
            
            The returned DynamicMetaObject may be strongly typed to a value type which needs boxing before being
            returned from a standard DLR GetMemberBinder.  The language is responsible for performing any boxing
            so that it has an opportunity to perform custom boxing.
            </returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetMember(System.String,System.Dynamic.DynamicMetaObject,System.Boolean,System.Dynamic.DynamicMetaObject)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
            <param name="isNoThrow">
            True if the operation should return Operation.Failed on failure, false if it
            should return the exception produced by MakeMissingMemberError.
            </param>
            <param name="errorSuggestion">
            The meta object to be used if the get results in an error.
            </param>
            <returns>
            Returns a DynamicMetaObject which represents the value that will be returned when the member is accessed.
            
            The returned DynamicMetaObject may be strongly typed to a value type which needs boxing before being
            returned from a standard DLR GetMemberBinder.  The language is responsible for performing any boxing
            so that it has an opportunity to perform custom boxing.
            </returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeOperatorGetMemberBody(Microsoft.Scripting.Actions.DefaultBinder.GetMemberInfo,System.Dynamic.DynamicMetaObject,System.Type,System.String)">
            <summary> if a member-injector is defined-on or registered-for this type call it </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DefaultBinder.GetMemberInfo">
            <summary>
            Helper class for flowing information about the GetMember request.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.Call(Microsoft.Scripting.Actions.CallSignature,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
            <summary>
            Provides default binding for performing a call on the specified meta objects.
            </summary>
            <param name="signature">The signature describing the call</param>
            <param name="target">The meta object to be called.</param>
            <param name="args">
            Additional meta objects are the parameters for the call as specified by the CallSignature in the CallAction.
            </param>
            <returns>A MetaObject representing the call or the error.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.Call(Microsoft.Scripting.Actions.CallSignature,Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
            <summary>
            Provides default binding for performing a call on the specified meta objects.
            </summary>
            <param name="signature">The signature describing the call</param>
            <param name="target">The meta object to be called.</param>
            <param name="args">
            Additional meta objects are the parameters for the call as specified by the CallSignature in the CallAction.
            </param>
            <param name="resolverFactory">Overload resolver factory.</param>
            <returns>A MetaObject representing the call or the error.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.Call(Microsoft.Scripting.Actions.CallSignature,System.Dynamic.DynamicMetaObject,Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
            <summary>
            Provides default binding for performing a call on the specified meta objects.
            </summary>
            <param name="signature">The signature describing the call</param>
            <param name="target">The meta object to be called.</param>
            <param name="args">
            Additional meta objects are the parameters for the call as specified by the CallSignature in the CallAction.
            </param>
            <param name="resolverFactory">Overload resolver factory.</param>
            <param name="errorSuggestion">The result should the object be uncallable.</param>
            <returns>A MetaObject representing the call or the error.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetTargetInfo(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[])">
            <summary>
            Gets a TargetInfo object for performing a call on this object.  
            
            If this object is a delegate we bind to the Invoke method.
            If this object is a MemberGroup or MethodGroup we bind to the methods in the member group.
            If this object is a BoundMemberTracker we bind to the methods with the bound instance.
            If the underlying type has defined an operator Call method we'll bind to that method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryGetMethodGroupTargets(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],Microsoft.Scripting.Actions.MethodGroup)">
            <summary>
            Binds to the methods in a method group.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryGetMemberGroupTargets(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],Microsoft.Scripting.Actions.MemberGroup)">
            <summary>
            Binds to the methods in a member group.  
            
            TODO: We should really only have either MemberGroup or MethodGroup, not both.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryGetBoundMemberTargets(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],Microsoft.Scripting.Actions.BoundMemberTracker)">
            <summary>
            Binds to the BoundMemberTracker and uses the instance in the tracker and restricts
            based upon the object instance type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryGetDelegateTargets(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Delegate)">
            <summary>
            Binds to the Invoke method on a delegate if this is a delegate type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryGetOperatorTargets(System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Object)">
            <summary>
            Attempts to bind to an operator Call method.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.DefaultBinder.TargetInfo">
            <summary>
            Encapsulates information about the target of the call.  This includes an implicit instance for the call,
            the methods that we'll be calling as well as any restrictions required to perform the call.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallMethod(Microsoft.Scripting.Actions.DefaultOverloadResolver,System.Collections.Generic.IList{System.Reflection.MethodBase})">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments.  The arguments are
            consumed as specified by the CallSignature object.
            </summary>
            <param name="resolver">Overload resolver.</param>
            <param name="targets">The methods to be called</param>
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallMethod(Microsoft.Scripting.Actions.DefaultOverloadResolver,System.Collections.Generic.IList{System.Reflection.MethodBase},System.String)">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments.  The arguments are
            consumed as specified by the CallSignature object.
            </summary>
            <param name="resolver">Overload resolver.</param>
            <param name="targets">The methods to be called</param>
            <param name="name">The name of the method or null to use the name from targets.</param>
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallMethod(Microsoft.Scripting.Actions.DefaultOverloadResolver,System.Collections.Generic.IList{System.Reflection.MethodBase},System.Dynamic.BindingRestrictions)">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments.  The arguments are
            consumed as specified by the CallSignature object.
            </summary>
            <param name="resolver">Overload resolver.</param>
            <param name="targets">The methods to be called</param>
            <param name="restrictions">Additional restrictions which should be applied to the resulting MetaObject.</param>
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallMethod(Microsoft.Scripting.Actions.DefaultOverloadResolver,System.Collections.Generic.IList{System.Reflection.MethodBase},System.Dynamic.BindingRestrictions,System.String)">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments.  The arguments are
            consumed as specified by the CallSignature object.
            </summary>
            <param name="resolver">Overload resolver.</param>
            <param name="targets">The methods to be called</param>
            <param name="restrictions">Additional restrictions which should be applied to the resulting MetaObject.</param>
            <param name="name">The name of the method or null to use the name from targets.</param>
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.CallMethod(Microsoft.Scripting.Actions.DefaultOverloadResolver,System.Collections.Generic.IList{System.Reflection.MethodBase},System.Dynamic.BindingRestrictions,System.String,Microsoft.Scripting.Actions.Calls.NarrowingLevel,Microsoft.Scripting.Actions.Calls.NarrowingLevel,Microsoft.Scripting.Actions.Calls.BindingTarget@)">
            <summary>
            Performs binding against a set of overloaded methods using the specified arguments.  The arguments are
            consumed as specified by the CallSignature object.
            </summary>
            <param name="minLevel">TODO.</param>
            <param name="maxLevel">TODO.</param>
            <param name="resolver">Overload resolver.</param>
            <param name="targets">The methods to be called</param>
            <param name="restrictions">Additional restrictions which should be applied to the resulting MetaObject.</param>
            <param name="target">The resulting binding target which can be used for producing error information.</param>
            <param name="name">The name of the method or null to use the name from targets.</param>
            <returns>A meta object which results from the call.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeSplatTests(Microsoft.Scripting.Runtime.CallTypes,Microsoft.Scripting.Actions.CallSignature,System.Boolean,System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject})">
            <summary>
            Makes test for param arrays and param dictionary parameters.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeParamsArrayTest(Microsoft.Scripting.Runtime.CallTypes,Microsoft.Scripting.Actions.CallSignature,System.Boolean,System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject})">
            <summary>
            Pulls out the right argument to build the splat test.  MakeParamsTest makes the actual test.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeParamsTest(System.Dynamic.DynamicMetaObject,System.Boolean)">
            <summary>
            Builds the restrictions for calling with a splatted argument array.  Ensures that the
            argument is still an ICollection of object and that it has the same number of arguments.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeParamsDictionaryTest(System.Collections.Generic.IList{System.Dynamic.DynamicMetaObject},System.Boolean)">
            <summary>
            Builds the restrictions for calling with keyword arguments.  The restrictions include
            tests on the individual keys of the dictionary to ensure they have the same names.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.GetIndex(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,System.Dynamic.DynamicMetaObject[])">
            <summary>
            Creates the MetaObject for indexing directly into arrays or indexing into objects which have
            default members.  Returns null if we're not an indexing operation.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.SetIndex(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,System.Dynamic.DynamicMetaObject[])">
            <summary>
            Creates the MetaObject for indexing directly into arrays or indexing into objects which have
            default members.  Returns null if we're not an indexing operation.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeGeneralOperatorRule(System.String,Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,System.Dynamic.DynamicMetaObject[])">
            <summary>
            Creates the meta object for the rest of the operations: comparisons and all other
            ExpressionType.  If the operation cannot be completed a MetaObject which indicates an
            error will be returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeGeneralOperatorRule(System.Linq.Expressions.ExpressionType,Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,System.Dynamic.DynamicMetaObject[])">
            <summary>
            Creates the meta object for the rest of the operations: comparisons and all other
            ExpressionType.  If the operation cannot be completed a MetaObject which indicates an
            error will be returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.TryNullComparisonRule(System.Dynamic.DynamicMetaObject[])">
            <summary>
            Produces a rule for comparing a value to null - supports comparing object references and nullable types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.SetMember(System.String,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
            <param name="value">
            The value being assigned to the target member.
            </param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.SetMember(System.String,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,Microsoft.Scripting.Actions.Calls.OverloadResolverFactory)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
            <param name="value">
            The value being assigned to the target member.
            </param>
            <param name="resolverFactory">
            Provides overload resolution and method binding for any calls which need to be performed for the SetMember.
            </param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.SetMember(System.String,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
            <param name="value">
            The value being assigned to the target member.
            </param>
            <param name="errorSuggestion">
            Provides a DynamicMetaObject that is to be used as the result if the member cannot be set.  If null then then a language
            specific error code is provided by ActionBinder.MakeMissingMemberErrorForAssign which can be overridden by the language.
            </param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.SetMember(System.String,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,Microsoft.Scripting.Actions.Calls.OverloadResolverFactory)">
            <summary>
            Builds a MetaObject for performing a member get.  Supports all built-in .NET members, the OperatorMethod 
            GetBoundMember, and StrongBox instances.
            </summary>
            <param name="name">
            The name of the member to retrieve.  This name is not processed by the DefaultBinder and
            is instead handed off to the GetMember API which can do name mangling, case insensitive lookups, etc...
            </param>
            <param name="target">
            The MetaObject from which the member is retrieved.
            </param>
            <param name="value">
            The value being assigned to the target member.
            </param>
            <param name="resolverFactory">
            Provides overload resolution and method binding for any calls which need to be performed for the SetMember.
            </param>
            <param name="errorSuggestion">
            Provides a DynamicMetaObject that is to be used as the result if the member cannot be set.  If null then then a language
            specific error code is provided by ActionBinder.MakeMissingMemberErrorForAssign which can be overridden by the language.
            </param>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DefaultBinder.MakeOperatorSetMemberBody(Microsoft.Scripting.Actions.DefaultBinder.SetOrDeleteMemberInfo,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Type,System.String)">
            <summary> if a member-injector is defined-on or registered-for this type call it </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.DynamicSiteHelpers.IsInvisibleDlrStackFrame(System.Reflection.MethodBase)">
            <summary>
            Returns true if the method should not be displayed in the stack frame.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ErrorInfo">
            <summary>
            Encapsulates information about the result that should be produced when 
            a OldDynamicAction cannot be performed.  The ErrorInfo can hold one of:
                an expression which creates an Exception to be thrown 
                an expression which produces a value which should be returned 
                    directly to the user and represents an error has occured (for
                    example undefined in JavaScript)
                an expression which produces a value which should be returned
                    directly to the user but does not actually represent an error.
            
            ErrorInfo's are produced by an ActionBinder in response to a failed
            binding.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ErrorInfo.#ctor(System.Linq.Expressions.Expression,Microsoft.Scripting.Actions.ErrorInfoKind)">
            <summary>
            Private constructor - consumers must use static From* factories
            to create ErrorInfo objects.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ErrorInfo.FromException(System.Linq.Expressions.Expression)">
            <summary>
            Creates a new ErrorInfo which represents an exception that should
            be thrown.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ErrorInfo.FromValue(System.Linq.Expressions.Expression)">
            <summary>
            Creates a new ErrorInfo which represents a value which should be
            returned to the user.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ErrorInfo.FromValueNoError(System.Linq.Expressions.Expression)">
            <summary>
            Crates a new ErrorInfo which represents a value which should be returned
            to the user but does not represent an error.
            </summary>
            <param name="resultValue"></param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ErrorInfoKind.Exception">
            <summary>
            The ErrorInfo expression produces an exception
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ErrorInfoKind.Error">
            <summary>
            The ErrorInfo expression produces a value which represents the error (e.g. undefined)
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.ErrorInfoKind.Success">
            <summary>
            The ErrorInfo expression produces a value which is not an error
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ErrorMetaObject">
            <summary>
            A MetaObject which was produced as the result of a failed binding.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.EventTracker.IsStatic">
            <summary>
            Doesn't need to check PrivateBinding setting: no method that is part of the event is public the entire event is private. 
            If the code has already a reference to the event tracker instance for a private event its "static-ness" is not influenced 
            by private-binding setting.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.EventTracker.GetComHandlerList(System.Object)">
            <summary>
            Gets the stub list for a COM Object.  For COM objects we store the stub list
            directly on the object using the Marshal APIs.  This allows us to not have
            any circular references to deal with via weak references which are challenging
            in the face of COM.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.EventTracker.HandlerList">
            <summary>
            Holds on a list of delegates hooked to the event. 
            We need the list because we cannot enumerate the delegates hooked to CLR event and we need to do so in 
            handler removal (we need to do custom delegate comparison there). If BCL enables the enumeration we could remove this.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.EventTracker.ComHandlerList._handlers">
            <summary>
            Storage for the handlers - a key value pair of the callable object and the delegate handler.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.EventTracker.NormalHandlerList._handlers">
            <summary>
            Storage for the handlers - a key value pair of the callable object and the delegate handler.
            
            The delegate handler is closed over the callable object.  Therefore as long as the object is alive the
            delegate will stay alive and so will the callable object.  That means it's fine to have a weak reference
            to both of these objects.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ExtensionMethodTracker">
            <summary>
            Represents extension method.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.ExtensionMethodTracker.DeclaringType">
            <summary>
            Gets the declaring type of the extension method. Since this is an extension method,
            the declaring type is in fact the type this extension method extends,
            not Method.DeclaringType
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.ILightExceptionBinder">
             <summary>
             Implemented by binders which support light exceptions.  Dynamic objects
             binding against a binder which implements this interface can check 
             SupportsLightThrow to see if the binder currently supports safely 
             returning a light exception.  Light exceptions can be created with
             LightException.Throw.
            
             Binders also need to implement GetlightBinder.  This method
             returns a new call site binder which may return light  exceptions if 
             the binder supports them.
             </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.ILightExceptionBinder.SupportsLightThrow">
            <summary>
            Returns true if a callsite binding against this binder can
            return light exceptions.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.ILightExceptionBinder.GetLightExceptionBinder">
            <summary>
            Gets a binder which will support light exception if one is
            available.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.Interceptor">
            <summary>
            Interceptor prototype. The interceptor is a call site binder that wraps
            a real call site binder and can perform arbitrary operations on the expression
            trees that the wrapped binder produces:
              * Dumping the trees
              * Additional rewriting
              * Static compilation
              * ...
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.MemberGroup">
            <summary>
            MemberGroups are a collection of MemberTrackers which are commonly produced
            on-demand to talk about the available members.  They can consist of a mix of
            different member types or multiple membes of the same type.
            
            The most common source of MemberGroups is from ActionBinder.GetMember.  From here
            the DLR will perform binding to the MemberTrackers frequently producing the value
            resulted from the user.  If the result of the action produces a member it's self
            the ActionBinder can provide the value exposed to the user via ReturnMemberTracker.
            
            ActionBinder provides default functionality for both getting members from a type
            as well as exposing the members to the user.  Getting members from the type maps
            closely to reflection and exposing them to the user exposes the MemberTrackers
            directly.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.MemberRequestKind">
            <summary>
            Specifies the action for which the default binder is requesting a member.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.MemberTracker">
            <summary>
            Represents a logical member of a type.  The member could either be real concrete member on a type or
            an extension member.
            
            This seperates the "physical" members that .NET knows exist on types from the members that
            logically exist on a type.  It also provides other abstractions above the level of .NET reflection
            such as MemberGroups and NamespaceTracker's.
            
            It also provides a wrapper around the reflection APIs which cannot be extended from partial trust.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.MemberTracker.MemberKey">
            <summary>
            We ensure we only produce one MemberTracker for each member which logically lives on the declaring type.  So 
            for example if you get a member from a derived class which is declared on the base class it should be the same 
            as getting the member from the base class.  Thats easy enough until you get into extension members  here there
            might be one extension member which is being applied to multiple types.  Therefore we need to take into account the 
            extension type when ensuring that we only have 1 MemberTracker ever created.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.MemberTracker.MemberType">
            <summary>
            The type of member tracker.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.MemberTracker.DeclaringType">
            <summary>
            The logical declaring type of the member.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.MemberTracker.Name">
            <summary>
            The name of the member.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.GetValue(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,Microsoft.Scripting.Actions.ActionBinder,System.Type)">
            <summary>
            Gets the expression that creates the value.  
            
            Returns null if it's an error to get the value.  The caller can then call GetErrorForGet to get 
            the correct error Expression (or null if they should provide a default).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.SetValue(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,Microsoft.Scripting.Actions.ActionBinder,System.Type,System.Dynamic.DynamicMetaObject)">
            <summary>
            Gets an expression that assigns a value to the left hand side.
            
            Returns null if it's an error to assign to.  The caller can then call GetErrorForSet to
            get the correct error Expression (or null if a default error should be provided).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.SetValue(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,Microsoft.Scripting.Actions.ActionBinder,System.Type,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
            <summary>
            Gets an expression that assigns a value to the left hand side.
            
            Returns null if it's an error to assign to.  The caller can then call GetErrorForSet to
            get the correct error Expression (or null if a default error should be provided).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.Call(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,Microsoft.Scripting.Actions.ActionBinder,System.Dynamic.DynamicMetaObject[])">
            <summary>
            Gets an expression that performs a call on the object using the specified arguments.
            
            Returns null if it's an error to perform the specific operation.  The caller can then call 
            GetErrorsForDoCall to get the correct error Expression (or null if a default error should be provided).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.GetError(Microsoft.Scripting.Actions.ActionBinder,System.Type)">
            <summary>
            Returns the error associated with getting the value.  
            
            A null return value indicates that the default error message should be provided by the caller.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.GetBoundError(Microsoft.Scripting.Actions.ActionBinder,System.Dynamic.DynamicMetaObject,System.Type)">
            <summary>
            Returns the error associated with accessing this member via a bound instance.
            
            A null return value indicates that the default error message should be provided by the caller.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.GetBoundValue(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,Microsoft.Scripting.Actions.ActionBinder,System.Type,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper for getting values that have been bound.  Called from BoundMemberTracker.  Custom member
            trackers can override this to provide their own behaviors when bound to an instance.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.SetBoundValue(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,Microsoft.Scripting.Actions.ActionBinder,System.Type,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper for setting values that have been bound.  Called from BoundMemberTracker.  Custom member
            trackers can override this to provide their own behaviors when bound to an instance.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.SetBoundValue(Microsoft.Scripting.Actions.Calls.OverloadResolverFactory,Microsoft.Scripting.Actions.ActionBinder,System.Type,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject)">
            <summary>
            Helper for setting values that have been bound.  Called from BoundMemberTracker.  Custom member
            trackers can override this to provide their own behaviors when bound to an instance.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MemberTracker.BindToInstance(System.Dynamic.DynamicMetaObject)">
            <summary>
            Binds the member tracker to the specified instance rturning a new member tracker if binding 
            is possible.  If binding is not possible the existing member tracker will be returned.  For example
            binding to a static field results in returning the original MemberTracker.  Binding to an instance
            field results in a new BoundMemberTracker which will get GetBoundValue/SetBoundValue to pass the
            instance through.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.MethodGroup">
            <summary>
            MethodGroup's represent a unique collection of method's.  Typically this
            unique set is all the methods which are overloaded by the same name including
            methods with different arity.  These methods represent a single logically
            overloaded element of a .NET type.
            
            The base DLR binders will produce MethodGroup's when provided with a MemberGroup
            which contains only methods.  The MethodGroup's will be unique instances per
            each unique group of methods.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.MethodGroup.MakeGenericMethod(System.Type[])">
            <summary>
            Returns a BuiltinFunction bound to the provided type arguments.  Returns null if the binding
            cannot be performed.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.NamespaceTracker">
            <summary>
            NamespaceTracker represent a CLS namespace.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.NamespaceTracker.LoadAllTypes">
            <summary>
            Loads all the types from all assemblies that contribute to the current namespace (but not child namespaces)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.NamespaceTracker.GetOrMakePackageHierarchy(System.Reflection.Assembly,System.String)">
            <summary>
            Populates the tree with nodes for each part of the namespace
            </summary>
            <param name="assem"></param>
            <param name="fullNamespace">Full namespace name. It can be null (for top-level types)</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.NamespaceTracker.CheckForUnlistedType(System.String)">
            <summary>
            As a fallback, so if the type does exist in any assembly. This would happen if a new type was added
            that was not in the hardcoded list of types. 
            This code is not accurate because:
            1. We dont deal with generic types (TypeCollision). 
            2. Previous calls to GetCustomMemberNames (eg. "from foo import *" in Python) would not have included this type.
            3. This does not deal with new namespaces added to the assembly
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.NamespaceTracker.TypeNames">
            <summary>
            This stores all the public non-nested type names in a single namespace and from a single assembly.
            This allows inspection of the namespace without eagerly loading all the types. Eagerly loading
            types slows down startup, increases working set, and is semantically incorrect as it can trigger
            TypeLoadExceptions sooner than required.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.NoSideEffectsAttribute">
            <summary>
            Marks a method as not having side effects.  used by the combo binder
            to allow calls to methods.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.OperatorInfo">
            <summary>
            OperatorInfo provides a mapping from DLR ExpressionType to their associated .NET methods.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.OperatorInfo.GetOperatorInfo(System.Linq.Expressions.ExpressionType)">
            <summary>
            Given an operator returns the OperatorInfo associated with the operator or null
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.OperatorInfo.Operator">
            <summary>
            Gets the operator the OperatorInfo provides info for.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.OperatorInfo.Name">
            <summary>
            Gets the primary method name associated with the method.
            This method name is usally in the form of op_Operator (e.g. op_Addition).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.OperatorInfo.AlternateName">
            <summary>
            Gets the secondary method name associated with the method.
            This method name is usually a standard .NET method name with pascal casing (e.g. Add).
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.PropertyTracker">
            <summary>
            Represents a logical Property as a member of a Type.  This Property can either be a real 
            concrete Property on a type (implemented with a ReflectedPropertyTracker) or an extension
            property (implemented with an ExtensionPropertyTracker).
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Actions.TopNamespaceTracker">
            <summary>
            Represents the top reflected package which contains extra information such as
            all the assemblies loaded and the built-in modules.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TopNamespaceTracker.TryGetPackage(System.String)">
            <summary>
            returns the package associated with the specified namespace and
            updates the associated module to mark the package as imported.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TopNamespaceTracker.LoadAssembly(System.Reflection.Assembly)">
            <summary>
            Ensures that the assembly is loaded
            </summary>
            <param name="assem"></param>
            <returns>true if the assembly was loaded for the first time. 
            false if the assembly had already been loaded before</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TopNamespaceTracker.PublishComTypes(System.Reflection.Assembly)">
            <summary>
            When an (interop) assembly is loaded, we scan it to discover the GUIDs of COM interfaces so that we can
            associate the type definition with COM objects with that GUID.
            Since scanning all loaded assemblies can be expensive, in the future, we might consider a more explicit 
            user binder to trigger scanning of COM types.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Constructor">
            <summary> Specifies that the member is a constructor, representing a ConstructorTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Event">
            <summary> Specifies that the member is an event, representing a EventTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Field">
            <summary> Specifies that the member is a field, representing a FieldTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Method">
            <summary> Specifies that the member is a method, representing a MethodTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Property">
            <summary> Specifies that the member is a property, representing a PropertyTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Type">
            <summary> Specifies that the member is a property, representing a TypeTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Namespace">
            <summary> Specifies that the member is a namespace, representing a NamespaceTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.MethodGroup">
            <summary> Specifies that the member is a group of method overloads, representing a MethodGroup</summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.TypeGroup">
            <summary> Specifies that the member is a group of types that very by arity, representing a TypeGroup</summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Custom">
            <summary> Specifies that the member is a custom meber, represetning a CustomTracker </summary>
        </member>
        <member name="F:Microsoft.Scripting.Actions.TrackerTypes.Bound">
            <summary> Specifies that the member is a bound to an instance, representing a BoundMemberTracker</summary>        
        </member>
        <member name="T:Microsoft.Scripting.Actions.TypeGroup">
            <summary>
            A TypeCollision is used when we have a collision between
            two types with the same name.  Currently this is only possible w/ generic
            methods that should logically have arity as a portion of their name. For eg:
                 System.EventHandler and System.EventHandler[T]
                 System.Nullable and System.Nullable[T]
                 System.IComparable and System.IComparable[T]
            
            The TypeCollision provides an indexer but also is a real type.  When used
            as a real type it is the non-generic form of the type.
            
            The indexer allows the user to disambiguate between the generic and
            non-generic versions.  Therefore users must always provide additional
            information to get the generic version.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TypeGroup.UpdateTypeEntity(Microsoft.Scripting.Actions.TypeTracker,Microsoft.Scripting.Actions.TypeTracker)">
            <param name="existingTypeEntity">The merged list so far. Could be null</param>
            <param name="newType">The new type(s) to add to the merged list</param>
            <returns>The merged list.  Could be a TypeTracker or TypeGroup</returns>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TypeGroup.GetGenericArity(System.Type)">
            <summary> Gets the arity of generic parameters</summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TypeGroup.GetNonGenericType">
            <exception cref="T:System.TypeLoadException">No non-generic type is represented by this group.</exception>
        </member>
        <member name="P:Microsoft.Scripting.Actions.TypeGroup.DeclaringType">
            <summary>
            This returns the DeclaringType of all the types in the TypeGroup
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.TypeGroup.Name">
            <summary>
            This returns the base name of the TypeGroup (the name shared by all types minus arity)
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.TypeGroup.Type">
            <summary>
            This will return the result only for the non-generic type if one exists, and will throw 
            an exception if all types in the TypeGroup are generic
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Actions.TypeGroup.IsPublic">
            <summary>
            This will return the result only for the non-generic type if one exists, and will throw 
            an exception if all types in the TypeGroup are generic
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Actions.TypeTracker.op_Explicit(Microsoft.Scripting.Actions.TypeTracker)~System.Type">
            <summary>
            Enables implicit Type to TypeTracker conversions accross dynamic languages.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.Utils">
            <summary>
            Factory methods.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.Coalesce(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression@)">
            <summary>
            Null coalescing expression
            {result} ::= ((tmp = {_left}) == null) ? {right} : tmp
            '??' operator in C#.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.CoalesceTrue(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.ParameterExpression@)">
            <summary>
            True coalescing expression.
            {result} ::= IsTrue(tmp = {left}) ? {right} : tmp
            Generalized AND semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.CoalesceFalse(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.ParameterExpression@)">
            <summary>
            False coalescing expression.
            {result} ::= IsTrue(tmp = {left}) ? tmp : {right}
            Generalized OR semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.CoalesceTrue(Microsoft.Scripting.Ast.LambdaBuilder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
            <summary>
            True coalescing expression.
            {result} ::= IsTrue(tmp = {left}) ? {right} : tmp
            Generalized AND semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.CoalesceFalse(Microsoft.Scripting.Ast.LambdaBuilder,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Reflection.MethodInfo)">
            <summary>
            False coalescing expression.
            {result} ::= IsTrue(tmp = {left}) ? tmp : {right}
            Generalized OR semantics.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.WeakConstant(System.Object)">
            <summary>
            Wraps the given value in a WeakReference and returns a tree that will retrieve
            the value from the WeakReference.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.Generator(System.Linq.Expressions.LabelTarget,System.Linq.Expressions.Expression)">
            <summary>
            Creates a generator with type IEnumerable{T}, where T is the label.Type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.TransformEnumerable(System.Linq.Expressions.Expression,System.Collections.ObjectModel.ReadOnlyCollection{System.Linq.Expressions.ParameterExpression})">
            
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.Lambda(System.Type,System.String)">
            <summary>
            Creates new instance of the LambdaBuilder with the specified name and return type.
            </summary>
            <param name="returnType">Return type of the lambda being built.</param>
            <param name="name">Name for the lambda being built.</param>
            <returns>new LambdaBuilder instance</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.SimpleCallHelper(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
            <summary>
            The helper to create the AST method call node. Will add conversions (Utils.Convert)
            to parameters and instance if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.SimpleCallHelper(System.Linq.Expressions.Expression,System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
            <summary>
            The helper to create the AST method call node. Will add conversions (Utils.Convert)
            to parameters and instance if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.ComplexCallHelper(System.Reflection.MethodInfo,System.Linq.Expressions.Expression[])">
            <summary>
            The complex call helper to create the AST method call node.
            Will add conversions (Expression.Convert()), deals with default parameter values and params arrays.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.Void(System.Linq.Expressions.Expression)">
            <summary>
            Converts an expression to a void type.
            </summary>
            <param name="expression">An <see cref="T:System.Linq.Expressions.Expression"/> to convert to void. </param>
            <returns>An <see cref="T:System.Linq.Expressions.Expression" /> that has the <see cref="P:System.Linq.Expressions.Expression.NodeType" /> property equal to <see cref="F:System.Linq.Expressions.ExpressionType.ConvertChecked" /> and the <see cref="P:System.Linq.Expressions.UnaryExpression.Operand" /> and <see cref="P:System.Linq.Expressions.Expression.Type" /> property set to void.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.Box(System.Linq.Expressions.Expression)">
            <summary>
            Returns an expression that boxes a given value. Uses boxed objects cache for Int32 and Boolean types.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.IsAssignment(System.Linq.Expressions.ExpressionType)">
            <summary>
            Determines whether specified expression type represents an assignment.
            </summary>
            <returns>
            True if the expression type represents an assignment.
            </returns>
            <remarks>
            Note that some other nodes can also assign to variables, members or array items:
            MemberInit, NewArrayInit, Call with ref params, New with ref params, Dynamic with ref params.
            </remarks>
        </member>
        <member name="M:Microsoft.Scripting.Ast.Utils.GetLValueAccess(System.Linq.Expressions.ExpressionType)">
            <summary>
            Determines if the left child of the given expression is read or written to or both.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.BlockBuilder.ToExpression">
            <summary>
            Returns <c>null</c> if no expression was added into the builder.
            If only a single expression was added returns it.
            Otherwise returns a <see cref="T:System.Linq.Expressions.BlockExpression"/> containing the expressions added to the builder.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.ExpressionCollectionBuilder`1.Expressions">
            <summary>
            If the number of items added to the builder is greater than 4 returns a read-only collection builder containing all the items.
            Returns <c>null</c> otherwise.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.FinallyFlowControlExpression">
            <summary>
            Wrapping a tree in this node enables jumps from finally blocks
            It does this by generating control-flow logic in the tree
            
            Reducing this node requires a full tree walk of its body
            (but not nested lambdas)
            
            WARNING: this node cannot contain jumps across blocks, because it
            assumes any unknown jumps are jumps to an outer scope.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.FlowControlRewriter">
            <summary>
            The purpose of this rewriter is simple: ETs do not allow jumps (break, continue, return, goto)
            that would go through a finally/fault. So we replace them with code that instead stores a flag,
            and then jumps to the end of the finally/fault. At the end of the try-finally, we emit a switch
            that then jumps to the correct label.
            
            A few things that make this more complicated:
            
              1. If a finally contains a jump out, then jumps in the try/catch need to be replaced as well.
                 It's to support cases like this:
                     # returns 234
                     def foo():
                         try: return 123
                         finally: return 234 
                 
                 We need to replace the "return 123" because after it jumps, we'll go to the finally, which
                 might decide to jump again, but once the IL finally exits, it ignores the finally jump and
                 keeps going with the original jump. The moral of the story is: if any jumps in finally are
                 rewritten, try/catch jumps must be also.
                 
             2. To generate better code, we only have one state variable, so if we have to jump out of
                multiple finallys we just keep jumping. It looks sort of like this:
                  foo:
                  try { ... } finally {
                      try { ... } finally {
                        ...
                        if (...) {
                            // was: goto foo;
                            $flow = 1; goto endInnerFinally; 
                        }
                        ...
                        endInnerFinally:
                      }
                      switch ($flow) {
                          case 1: goto endOuterFinally;
                      }
                      ...
                      endOuterFinally:
                  }
                  switch ($flow) {
                    case 1: $flow = 0; goto foo;
                  }
                  ...
            
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.GeneratorExpression">
            <summary>
            A parameterless generator, that is of type IEnumerable, IEnumerable{T},
            IEnumerator, or IEnumerator{T}. Its body can contain a series of
            YieldExpressions. Each call into MoveNext on the enumerator reenters
            the generator, and executes until it reaches a YieldReturn or YieldBreak
            expression
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.GeneratorExpression.Target">
            <summary>
            The label used by YieldBreak and YieldReturn expressions to yield
            from this generator
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.GeneratorExpression.Body">
            <summary>
            The body of the generator, which can contain YieldBreak and
            YieldReturn expressions
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.GeneratorExpression.RewriteAssignments">
            <summary>
            Indicates whether the lhs instances are preserved when assignments
            are made to expressions containing yields.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.GeneratorRewriter">
            <summary>
            When finding a yield return or yield break, this rewriter flattens out
            containing blocks, scopes, and expressions with stack state. All
            scopes encountered have their variables promoted to the generator's
            closure, so they survive yields.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.GeneratorRewriter.MakeAssign(System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.Expression)">
            <summary>
            Makes an assignment to this variable. Pushes the assignment as far
            into the right side as possible, to allow jumps into it.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.GeneratorRewriter.IsConstant(System.Linq.Expressions.Expression)">
            <summary>
            Returns true if the expression remains constant no matter when it is evaluated.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.ILightExceptionAwareExpression">
            <summary>
            Implemented by expressions which can provide a version which is aware of light exceptions.  
            
            Normally these expressions will simply reduce to a version which throws a real exception.
            When the expression is used inside of a region of code which supports light exceptions
            the light exception re-writer will call ReduceForLightExceptions.  The expression can
            then return a new expression which can return a light exception rather than throwing
            a real .NET exception.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.LambdaBuilder">
            <summary>
            The builder for creating the LambdaExpression node.
            
            Since the nodes require that parameters and variables are created
            before hand and then passed to the factories creating LambdaExpression
            this builder keeps track of the different pieces and at the end creates
            the LambdaExpression.
            
            TODO: This has some functionality related to CodeContext that should be
            removed, in favor of languages handling their own local scopes
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.Name">
            <summary>
            The name of the lambda.
            Currently anonymous/unnamed lambdas are not allowed.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.ReturnType">
            <summary>
            Return type of the lambda being created.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.Locals">
            <summary>
            List of lambda's local variables for direct manipulation.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.Parameters">
            <summary>
            List of lambda's parameters for direct manipulation
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.ParamsArray">
            <summary>
            The params array argument, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.Body">
            <summary>
            The body of the lambda. This must be non-null.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.Dictionary">
            <summary>
            The generated lambda should have dictionary of locals
            instead of allocating them directly on the CLR stack.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.LambdaBuilder.Visible">
            <summary>
            The scope is visible (default). Invisible if false.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.Parameter(System.Type,System.String)">
            <summary>
            Creates a parameter on the lambda with a given name and type.
            
            Parameters maintain the order in which they are created,
            however custom ordering is possible via direct access to
            Parameters collection.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.ClosedOverParameter(System.Type,System.String)">
            <summary>
            Creates a parameter on the lambda with a given name and type.
            
            Parameters maintain the order in which they are created,
            however custom ordering is possible via direct access to
            Parameters collection.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.AddParameters(System.Linq.Expressions.ParameterExpression[])">
            <summary>
            adds existing parameter to the lambda.
            
            Parameters maintain the order in which they are created,
            however custom ordering is possible via direct access to
            Parameters collection.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.CreateHiddenParameter(System.String,System.Type)">
            <summary>
            Creates a hidden parameter on the lambda with a given name and type.
            
            Parameters maintain the order in which they are created,
            however custom ordering is possible via direct access to
            Parameters collection.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.CreateParamsArray(System.Type,System.String)">
            <summary>
            Creates a params array argument on the labmda.
            
            The params array argument is added to the signature immediately. Before the lambda is
            created, the builder validates that it is still the last (since the caller can modify
            the order of parameters explicitly by maniuplating the parameter list)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.ClosedOverVariable(System.Type,System.String)">
            <summary>
            Creates a local variable with specified name and type.
            TODO: simplify by pushing logic into callers
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.Variable(System.Type,System.String)">
            <summary>
            Creates a local variable with specified name and type.
            TODO: simplify by pushing logic into callers
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.HiddenVariable(System.Type,System.String)">
            <summary>
            Creates a temporary variable with specified name and type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.AddHiddenVariable(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Adds the temporary variable to the list of variables maintained
            by the builder. This is useful in cases where the variable is
            created outside of the builder.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.MakeLambda(System.Type)">
            <summary>
            Creates the LambdaExpression from the builder.
            After this operation, the builder can no longer be used to create other instances.
            </summary>
            <param name="lambdaType">Desired type of the lambda. </param>
            <returns>New LambdaExpression instance.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.MakeLambda">
            <summary>
            Creates the LambdaExpression from the builder.
            After this operation, the builder can no longer be used to create other instances.
            </summary>
            <returns>New LambdaExpression instance.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.MakeGenerator(System.Linq.Expressions.LabelTarget,System.Type)">
            <summary>
            Creates the generator LambdaExpression from the builder.
            After this operation, the builder can no longer be used to create other instances.
            </summary>
            <returns>New LambdaExpression instance.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.EnsureSignature(System.Type)">
            <summary>
            Fixes up lambda body and parameters to match the signature of the given delegate if needed.
            </summary>
            <param name="delegateType"></param>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LambdaBuilder.Validate">
            <summary>
            Validates that the builder has enough information to create the lambda.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.LightCheckAndThrowExpression">
            <summary>
            Provides a method call to a method which may return light exceptions. 
            
            The call is to a method which supports light exceptions.  When reducing
            an additional check and throw is added.  When a block code of is re-written
            for light exceptions this instead reduces to not throw a .NET exception.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.LightExceptionRewriter">
            <summary>
            Internal re-writer class which creates code which is light exception aware.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.LightExceptionRewriter.LightExceptionRewrittenCode">
            <summary>
            Class used to be avoid overhead of creating expression trees when we're usually 
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Ast.LightExceptionRewriter.CheckExpression(System.Linq.Expressions.Expression,System.Type)">
            <summary>
            Adds light exception handling to the provided expression which
            is light exception aware.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.LightThrowExpression">
            <summary>
            Expression which produces a light exception value.  This should be constructed
            with the expression which creates the exception and this method will then call
            a helper method which wraps the exception in our internal light exception class.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Ast.YieldExpression">
            <summary>
            Represents either a YieldBreak or YieldReturn in a GeneratorExpression
            If Value is non-null, it's a YieldReturn; otherwise it's a YieldBreak
            and executing it will stop enumeration of the generator, causing
            MoveNext to return false.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.YieldExpression.Value">
            <summary>
            The value yieled from this expression, if it is a yield return
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Ast.YieldExpression.Target">
            <summary>
            Gets the label used to yield from this generator
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers">
            <summary>
            These are some generally useful helper methods. Currently the only methods are those to
            cached boxed representations of commonly used primitive types so that they can be shared.
            This is useful to most dynamic languages that use object as a universal type.
            
            The methods in RuntimeHelepers are caleld by the generated code. From here the methods may
            dispatch to other parts of the runtime to get bulk of the work done, but the entry points
            should be here.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.ShiftParamsArray``1(``0[],System.Int32)">
            <summary>
            Used by prologue code that is injected in lambdas to ensure that delegate signature matches what 
            lambda body expects. Such code typically unwraps subset of the params array manually, 
            but then passes the rest in bulk if lambda body also expects params array.
            
            This calls ArrayUtils.ShiftLeft, but performs additional checks that
            ArrayUtils.ShiftLeft assumes.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.True">
            <summary>
            A singleton boxed boolean true.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.False">
             <summary>
            A singleton boxed boolean false.
             </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.Int32ToObject(System.Int32)">
            <summary>
            Gets a singleton boxed value for the given integer if possible, otherwise boxes the integer.
            </summary>
            <param name="value">The value to box.</param>
            <returns>The boxed value.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.CreateInstance``1">
            <summary>
            Helper method to create an instance.  Work around for Silverlight where Activator.CreateInstance
            is SecuritySafeCritical.
            
            TODO: Why can't we just emit the right thing for default(T)?
            It's always null for reference types and it's well defined for value types
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.GetEventHandlerType(System.Reflection.EventInfo)">
            <summary>
            EventInfo.EventHandlerType getter is marked SecuritySafeCritical in CoreCLR
            This method is to get to the property without using Reflection
            </summary>
            <param name="eventInfo"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ScriptingRuntimeHelpers.InterpretedCallSiteTest(System.Boolean,System.Object)">
            <summary>
            Provides the test to see if an interpreted call site should switch over to being compiled.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IExpressionSerializable">
            <summary>
            Enables an object to be serializable to an Expression tree.  The expression tree can then
            be emitted into an assembly enabling the de-serialization of the object.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ArgumentArray">
            <summary>
            Wraps all arguments passed to a dynamic site with more arguments than can be accepted by a Func/Action delegate.
            The binder generating a rule for such a site should unwrap the arguments first and then perform a binding to them.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ArgumentArray.Count">
            <summary>
            Gets the number of items in _arguments that represent the arguments.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.BinderOps">
            <summary>
            Helper methods that calls are generated to from the default DLR binders.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.BinderOps.GetCombinedParameters(System.Object[],System.Object)">
            <summary>
            Helper function to combine an object array with a sequence of additional parameters that has been splatted for a function call.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.BinderOps.GetEventHandlerType(System.Reflection.EventInfo)">
            <summary>
            EventInfo.EventHandlerType getter is marked SecuritySafeCritical in CoreCLR
            This method is to get to the property without using Reflection
            </summary>
            <param name="eventInfo"></param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.BinderType.Normal">
            <summary>
            The MethodBinder will perform normal method binding.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.BinderType.BinaryOperator">
            <summary>
            The MethodBinder will return the languages definition of NotImplemented if the arguments are
            incompatible with the signature.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.BinderType.Constructor">
            <summary>
            The MethodBinder will set properties/fields for unused keyword arguments on the instance 
            that gets returned from the method.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DlrMainCallTarget">
            <summary>
            The delegate representing the DLR Main function
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.Cast">
            <summary>
            Implements explicit casts supported by the runtime.
            </summary>
            <summary>
            Implements explicit casts supported by the runtime.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.Cast.Explicit(System.Object,System.Type)">
            <summary>
            Explicitly casts the object to a given type (and returns it as object)
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.CompilerContext">
            <summary>
            Represents the context that is flowed for doing Compiler.  Languages can derive
            from this class to provide additional contextual information.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.CompilerContext.SourceUnit">
            <summary>
            Gets the source unit currently being compiled in the CompilerContext.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.CompilerContext.ParserSink">
            <summary>
            Gets the sink for parser callbacks (e.g. brace matching, etc.).
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.CompilerContext.Errors">
            <summary>
            Gets the current error sink.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.CompilerContext.Options">
            <summary>
            Gets the compiler specific options.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.CustomStringDictionary">
            <summary>
            Abstract base class used for optimized thread-safe dictionaries which have a set
            of pre-defined string keys.
            
            Implementers derive from this class and override the GetExtraKeys, TrySetExtraValue, 
            and TryGetExtraValue methods. When looking up a value first the extra keys will be 
            searched using the optimized Try*ExtraValue functions.  If the value isn't found there
            then the value is stored in the underlying .NET dictionary.
            
            This dictionary can store object values in addition to string values.  It also supports
            null keys.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomStringDictionary.GetExtraKeys">
            <summary>
            Gets a list of the extra keys that are cached by the the optimized implementation
            of the module.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomStringDictionary.TrySetExtraValue(System.String,System.Object)">
            <summary>
            Try to set the extra value and return true if the specified key was found in the 
            list of extra values.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.CustomStringDictionary.TryGetExtraValue(System.String,System.Object@)">
            <summary>
            Try to get the extra value and returns true if the specified key was found in the
            list of extra values.  Returns true even if the value is Uninitialized.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DelegateInfo">
            <summary>
            Used as the value for the ScriptingRuntimeHelpers.GetDelegate method caching system
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DelegateInfo.EmitClrCallStub(Microsoft.Scripting.Generation.ILGen)">
            <summary>
            Generates stub to receive the CLR call and then call the dynamic language code.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DelegateSignatureInfo">
            <summary>
            Used as the key for the LanguageContext.GetDelegate method caching system
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DlrCachedCodeAttribute">
            <summary>
            An attribute that is applied to saved ScriptCode's to be used to re-create the ScriptCode
            from disk.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.CachedOptimizedCodeAttribute.Names">
            <summary>
            Gets names stored in optimized scope. 
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DocumentationAttribute">
            <summary>
            Provides a mechanism for providing documentation stored in an assembly as metadata.  
            
            Applying this attribute will enable documentation to be provided to the user at run-time
            even if XML Documentation files are unavailable.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DynamicDelegateCreator">
            <summary>
            Provides support for converting objects to delegates using the DLR binders
            available by the provided language context.
            
            Primarily this supports converting objects implementing IDynamicMetaObjectProvider
            to the appropriate delegate type.  
            
            If the provided object is already a delegate of the appropriate type then the 
            delegate will simply be returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicDelegateCreator.GetDelegate(System.Object,System.Type)">
            <summary>
            Creates a delegate with a given signature that could be used to invoke this object from non-dynamic code (w/o code context).
            A stub is created that makes appropriate conversions/boxing and calls the object.
            The stub should be executed within a context of this object's language.
            </summary>
            <returns>The converted delegate.</returns>
            <exception cref="T:Microsoft.Scripting.ArgumentTypeException">The object is either a subclass of Delegate but not the requested type or does not implement IDynamicMetaObjectProvider.</exception>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DynamicNull">
            <summary>
            Represents the type of a null value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicNull.#ctor">
            <summary>
            Private constructor is never called since 'null' is the only valid instance.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ExceptionHelpers.UpdateForRethrow(System.Exception)">
            <summary>
            Updates an exception before it's getting re-thrown so
            we can present a reasonable stack trace to the user.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ExceptionHelpers.GetExceptionStackTraces(System.Exception)">
            <summary>
            Returns all the stack traces associates with an exception
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ExtensionTypeAttribute">
            <summary>
            Marks a class in the assembly as being an extension type for another type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ExtensionTypeAttribute.#ctor(System.Type,System.Type)">
            <summary>
            Marks a type in the assembly as being an extension type for another type.
            </summary>
            <param name="extends">The type which is being extended</param>
            <param name="extensionType">The type which provides the extension members.</param>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ExtensionTypeAttribute.ExtensionType">
            <summary>
            The type which contains extension members which are added to the type being extended.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ExtensionTypeAttribute.Extends">
            <summary>
            The type which is being extended by the extension type.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IConvertibleMetaObject">
            <summary>
            Indicates that a DynamicMetaObject might be convertible to a CLR type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.IdDispenser.GetObject(System.Int64)">
            <summary>
            Given an ID returns the object associated with that ID.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.IdDispenser.GetId(System.Object)">
            <summary>
            Gets a unique ID for an object
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.IdDispenser.Cleanup">
            <summary>
            Goes over the hashtable and removes empty entries 
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IdDispenser.Wrapper">
            <summary>
            Weak-ref wrapper caches the weak reference, our hash code, and the object ID.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IdDispenser.WrapperComparer">
            <summary>
            WrapperComparer treats Wrapper as transparent envelope 
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IMembersList">
            <summary>
            Provides a list of all the members of an instance.  
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.IRestrictedMetaObject">
            <summary>
            Indicates that a MetaObject is already representing a restricted type.  Useful
            when we're already restricted to a known type but this isn't captured in
            the type info (e.g. the type is not sealed).
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ISlice">
            <summary>
            A useful interface for taking slices of numeric arrays, inspired by Python's Slice objects.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ISlice.Start">
            <summary>
            The starting index of the slice or null if no first index defined
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ISlice.Stop">
            <summary>
            The ending index of the slice or null if no ending index defined
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ISlice.Step">
            <summary>
            The length of step to take
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.LanguageBoundTextContentProvider">
            <summary>
            Internal class which binds a LanguageContext, StreamContentProvider, and Encoding together to produce
            a TextContentProvider which reads binary data with the correct language semantics.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.LightExceptions">
            <summary>
            Provides support for light exceptions.  These exceptions are propagated by
            returning an instance of a private wrapper class containing the exception.  Code
            which is aware of light exceptions will branch to apporiate exception handling
            blocks when in a try and otherwise return the value up the stack.  This avoids 
            using the underlying CLR exception mechanism with overhead such as creating stack 
            traces.
            
            When a light exception reaches the boundary of code which is not light exception
            aware the caller must check to see if a light exception is being thrown and if
            so raise a .NET exception.
            
            This class provides methods for re-writing expression trees to support light exceptions,
            methods to create light throw objects, check if an object is a light
            throw object, and turn such an object back into a .NET Exception which can be thrown.
            
            Light exceptions also don't build up stack traces or interoperate with filter blocks
            via 2-pass exception handling.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.Rewrite(System.Linq.Expressions.Expression)">
            <summary>
            Rewrites the provided expression to support light exceptions.  
            
            Calls to the returned expression, if not from other light-weight aware calls,
            need to call GetLightException on return to see if an exception was thrown
            and if so throw it.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.RewriteLazy(System.Linq.Expressions.Expression)">
            <summary>
            Returns a new expression which will lazily reduce to a light
            expression re-written version of the same expression.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.RewriteExternal(System.Linq.Expressions.Expression)">
            <summary>
            Returns a new expression which is re-written for light exceptions
            but will throw an exception if it escapes the expression.  If this
            expression is part of a larger experssion which is later re-written 
            for light exceptions then it will propagate the light exception up.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.Throw(System.Exception)">
            <summary>
            Returns an object which represents a light exception.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.Throw(System.Linq.Expressions.Expression)">
            <summary>
            Returns an object which represents a light exception.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.Throw(System.Linq.Expressions.Expression,System.Type)">
            <summary>
            Returns an object which represents a light exception.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.Throw(System.Dynamic.DynamicMetaObjectBinder,System.Linq.Expressions.Expression)">
            <summary>
            If the binder supports light exceptions then a light exception throwing expression is returned.
            
            Otherwise a normal throwing expression is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.Throw(System.Dynamic.DynamicMetaObjectBinder,System.Linq.Expressions.Expression,System.Type)">
            <summary>
            If the binder supports light exceptions then a light exception throwing expression is returned.
            
            Otherwise a normal throwing expression is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.CheckAndThrow(System.Object)">
            <summary>
            Throws the exception if the value represents a light exception
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.CheckAndThrow(System.Linq.Expressions.Expression)">
            <summary>
            Wraps the expression in a check and rethrow.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.IsLightException(System.Object)">
            <summary>
            Checks to see if the provided value is a light exception.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.GetLightException(System.Object)">
            <summary>
            Gets the light exception from an object which may contain a light
            exception.  Returns null if the object is not a light exception.
            
            Used for throwing the exception at non-light exception boundaries.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.LightExceptions.SupportsLightThrow(System.Runtime.CompilerServices.CallSiteBinder)">
            <summary>
            Returns true if the call site binder is a light exception binder and supports
            light throws.  Returns false otherwise.
            </summary>
            <param name="binder"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.LightExceptions.LightException">
            <summary>
            Sealed wrapper class to indicate something is a light exception.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.LightThrowingAttribute">
            <summary>
            Marks a method which may return a light exception.  Such
            methods need to have their return value checked and the exception
            will need to be thrown if the caller is not light exception aware.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.LocalsDictionary">
            <summary>
            Creates a dictionary of locals in this scope
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.MetaObjectExtensions.GetLimitType(System.Dynamic.DynamicMetaObject)">
             <summary>
            Returns Microsoft.Scripting.Runtime.DynamicNull if the object contains a null value,
            otherwise, returns self.LimitType
             </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.MetaObjectExtensions.GetRuntimeType(System.Dynamic.DynamicMetaObject)">
             <summary>
            Returns Microsoft.Scripting.Runtime.DynamicNull if the object contains a null value,
            otherwise, returns self.RuntimeType
             </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ModuleChangeEventArgs">
            <summary>
            Event args for when a ScriptScope has had its contents changed.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ModuleChangeEventArgs.#ctor(System.String,Microsoft.Scripting.Runtime.ModuleChangeType)">
            <summary>
            Creates a new ModuleChangeEventArgs object with the specified name and type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.ModuleChangeEventArgs.#ctor(System.String,Microsoft.Scripting.Runtime.ModuleChangeType,System.Object)">
            <summary>
            Creates a nwe ModuleChangeEventArgs with the specified name, type, and changed value.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ModuleChangeEventArgs.Name">
            <summary>
            Gets the name of the symbol that has changed.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ModuleChangeEventArgs.ChangeType">
            <summary>
            Gets the way in which the symbol has changed: Set or Delete.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.ModuleChangeEventArgs.Value">
            <summary>
            Gets the symbol has been set provides the new value.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ModuleChangeType">
            <summary>
            The way in which a module has changed : Set or Delete
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ModuleChangeType.Set">
            <summary>
            A new value has been set in the module (or a previous value has changed).
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Runtime.ModuleChangeType.Delete">
            <summary>
            A value has been removed from the module.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.NullTextContentProvider">
            <summary>
            A NullTextContentProvider to be provided when we have a pre-compiled ScriptCode which doesn't
            have source code associated with it.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.OperationFailed">
            <summary>
            Singleton instance returned from an operator method when the operator method cannot provide a value.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.OperatorSlotAttribute">
            <summary>
            Represents an ops-extension method which is added as an operator.
            
            The name must be a well-formed name such as "Add" that matches the CLS
            naming conventions for adding overloads associated with op_* methods.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.PositionTrackingWriter">
            <summary>
            Efficiently tracks (line,column) information as text is added, and
            collects line mappings between the original and generated source code
            so we can generate correct debugging information later
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.PositionTrackingWriter.MapLocation(System.CodeDom.CodeLinePragma)">
            <summary>
            Marks the current position of the writer as corresponding to the
            original location passed in
            </summary>
            <param name="linePragma">the line pragma corresponding to the 
            current position in the generated code</param>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.PropertyMethodAttribute">
            <summary>
            Represents an ops-extension method which is used to implement a property.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ReflectionCache">
            <summary>
            Provides a cache of reflection members.  Only one set of values is ever handed out per a 
            specific request.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.ReflectionCache.MethodBaseCache">
            <summary>
            TODO: Make me private again
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.StaticExtensionMethodAttribute">
            <summary>
            Indicates an extension method should be added as a static method, not a instance method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerBuffer.Seek(System.Int32)">
            <summary>
            Sets the current position inside current token or one character behind it.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerBuffer.SeekRelative(System.Int32)">
            <summary>
            Sets the current position inside current token or one character behind it.
            A relative displacement with respect to the current position in the token is specified.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerBuffer.MarkMultiLineTokenEnd">
            <summary>
            Marks token end. Enables to read the current token.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerBuffer.DiscardToken">
            <summary>
            Marks token start. It means the buffer can drop the current token.
            Can be called even if no token has been read yet.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerBuffer.ReadLine">
            <summary>
            Reads till the end of line and returns the character that stopped the reading.
            The returned character is not skipped.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.TokenizerBuffer.ResizeInternal(System.Char[]@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Resizes an array to a speficied new size and copies a portion of the original array into its beginning.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Runtime.DynamicXamlReader">
            <summary>
            Provides services for loading XAML and binding events to dynamic language code definitions.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicXamlReader.LoadComponent(System.Object,Microsoft.Scripting.Runtime.DynamicOperations,System.IO.Stream,System.Xaml.XamlSchemaContext)">
            <summary>
            Loads XAML from the specified stream and returns the deserialized object.  Any event handlers
            are bound to methods defined in the provided Scope and converted using the provided DynamicOperations
            object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicXamlReader.LoadComponent(System.Object,Microsoft.Scripting.Runtime.DynamicOperations,System.String,System.Xaml.XamlSchemaContext)">
            <summary>
            Loads XAML from the specified filename and returns the deserialized object.  Any event handlers
            are bound to methods defined in the provided Scope and converted using the provided DynamicOperations
            object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicXamlReader.LoadComponent(System.Object,Microsoft.Scripting.Runtime.DynamicOperations,System.Xml.XmlReader,System.Xaml.XamlSchemaContext)">
            <summary>
            Loads XAML from the specified XmlReader and returns the deserialized object.  Any event handlers
            are bound to methods defined in the provided Scope and converted using the provided DynamicOperations
            object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicXamlReader.LoadComponent(System.Object,Microsoft.Scripting.Runtime.DynamicOperations,System.IO.TextReader,System.Xaml.XamlSchemaContext)">
            <summary>
            Loads XAML from the specified TextReader and returns the deserialized object.  Any event handlers
            are bound to methods defined in the provided Scope and converted using the provided DynamicOperations
            object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicXamlReader.LoadComponent(System.Object,Microsoft.Scripting.Runtime.DynamicOperations,System.Xaml.XamlXmlReader)">
            <summary>
            Loads XAML from the specified XamlXmlReader and returns the deserialized object.  Any event handlers
            are bound to methods defined in the provided Scope and converted using the provided DynamicOperations
            object.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Runtime.DynamicXamlReader.DynamicWriter.Names">
            <summary>
            Returns the list of x:Name'd objects that we saw and should set on the root object.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Runtime.DynamicXamlReader.DynamicWriter.Adder(System.Object,System.Object)">
            <summary>
            Dummy, should never be called
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.SourceFileInformation">
            <summary>
            Stores information needed to emit debugging symbol information for a
            source file, in particular the file name and unique language identifier
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceFileInformation.FileName">
            <summary>
            Gets the source file name.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceFileInformation.LanguageGuid">
            <summary>
            Gets the language's unique identifier, if any.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.SourceFileInformation.VendorGuid">
            <summary>
            Gets the language vendor's unique identifier, if any.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.ArgBuilder">
            <summary>
            ArgBuilder provides an argument value used by the MethodBinder.  One ArgBuilder exists for each
            physical parameter defined on a method.  
            
            Contrast this with ParameterWrapper which represents the logical argument passed to the method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ArgBuilder.Marshal(System.Linq.Expressions.Expression)">
            <summary>
            Provides the Expression which provides the value to be passed to the argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ArgBuilder.MarshalToRef(System.Linq.Expressions.Expression)">
            <summary>
            Provides the Expression which provides the value to be passed to the argument.
            This method is called when result is intended to be used ByRef.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ArgBuilder.UnmarshalFromRef(System.Linq.Expressions.Expression)">
            <summary>
            Provides an Expression which will update the provided value after a call to the method.
            May return null if no update is required.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.BoundDispEvent.TryBinaryOperation(System.Dynamic.BinaryOperationBinder,System.Object,System.Object@)">
            <summary>
            Provides the implementation of performing AddAssign and SubtractAssign binary operations.
            </summary>
            <param name="binder">The binder provided by the call site.</param>
            <param name="handler">The handler for the operation.</param>
            <param name="result">The result of the operation.</param>
            <returns>true if the operation is complete, false if the call site should determine behavior.</returns>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.BoundDispEvent.InPlaceAdd(System.Object)">
            <summary>
            Adds a handler to an event.
            </summary>
            <param name="handler">The handler to be added.</param>
            <returns>The original event with handler added.</returns>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.BoundDispEvent.InPlaceSubtract(System.Object)">
            <summary>
            Removes handler from the event.
            </summary>
            <param name="handler">The handler to be removed.</param>
            <returns>The original event with handler removed.</returns>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.ComBinder">
            <summary>
            Provides helper methods to bind COM objects dynamically.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComBinder.IsComObject(System.Object)">
            <summary>
            Determines if an object is a COM object.
            </summary>
            <param name="value">The object to test.</param>
            <returns>true if the object is a COM object, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComBinder.TryBindGetMember(System.Dynamic.GetMemberBinder,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject@,System.Boolean)">
            <summary>
            Tries to perform binding of the dynamic get member operation.
            </summary>
            <param name="binder">An instance of the <see cref="T:System.Dynamic.GetMemberBinder"/> that represents the details of the dynamic operation.</param>
            <param name="instance">The target of the dynamic operation. </param>
            <param name="result">The new <see cref="T:System.Dynamic.DynamicMetaObject"/> representing the result of the binding.</param>
            <param name="delayInvocation">true if member evaluation may be delayed.</param>
            <returns>true if operation was bound successfully; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComBinder.TryBindGetMember(System.Dynamic.GetMemberBinder,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject@)">
            <summary>
            Tries to perform binding of the dynamic get member operation.
            </summary>
            <param name="binder">An instance of the <see cref="T:System.Dynamic.GetMemberBinder"/> that represents the details of the dynamic operation.</param>
            <param name="instance">The target of the dynamic operation. </param>
            <param name="result">The new <see cref="T:System.Dynamic.DynamicMetaObject"/> representing the result of the binding.</param>
            <returns>true if operation was bound successfully; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComBinder.TryBindSetMember(System.Dynamic.SetMemberBinder,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject@)">
            <summary>
            Tries to perform binding of the dynamic set member operation.
            </summary>
            <param name="binder">An instance of the <see cref="T:System.Dynamic.SetMemberBinder"/> that represents the details of the dynamic operation.</param>
            <param name="instance">The target of the dynamic operation.</param>
            <param name="value">The <see cref="T:System.Dynamic.DynamicMetaObject"/> representing the value for the set member operation.</param>
            <param name="result">The new <see cref="T:System.Dynamic.DynamicMetaObject"/> representing the result of the binding.</param>
            <returns>true if operation was bound successfully; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComBinder.TryBindInvoke(System.Dynamic.InvokeBinder,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject@)">
            <summary>
            Tries to perform binding of the dynamic invoke operation.
            </summary>    
            <param name="binder">An instance of the <see cref="T:System.Dynamic.InvokeBinder"/> that represents the details of the dynamic operation.</param>
            <param name="instance">The target of the dynamic operation. </param>
            <param name="args">An array of <see cref="T:System.Dynamic.DynamicMetaObject"/> instances - arguments to the invoke member operation.</param>
            <param name="result">The new <see cref="T:System.Dynamic.DynamicMetaObject"/> representing the result of the binding.</param>
            <returns>true if operation was bound successfully; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComBinder.TryBindInvokeMember(System.Dynamic.InvokeMemberBinder,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject@)">
            <summary>
            Tries to perform binding of the dynamic invoke member operation.
            </summary>
            <param name="binder">An instance of the <see cref="T:System.Dynamic.InvokeMemberBinder"/> that represents the details of the dynamic operation.</param>
            <param name="instance">The target of the dynamic operation. </param>
            <param name="args">An array of <see cref="T:System.Dynamic.DynamicMetaObject"/> instances - arguments to the invoke member operation.</param>
            <param name="result">The new <see cref="T:System.Dynamic.DynamicMetaObject"/> representing the result of the binding.</param>
            <returns>true if operation was bound successfully; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComBinder.TryBindGetIndex(System.Dynamic.GetIndexBinder,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject@)">
            <summary>
            Tries to perform binding of the dynamic get index operation.
            </summary>
            <param name="binder">An instance of the <see cref="T:System.Dynamic.GetIndexBinder"/> that represents the details of the dynamic operation.</param>
            <param name="instance">The target of the dynamic operation. </param>
            <param name="args">An array of <see cref="T:System.Dynamic.DynamicMetaObject"/> instances - arguments to the invoke member operation.</param>
            <param name="result">The new <see cref="T:System.Dynamic.DynamicMetaObject"/> representing the result of the binding.</param>
            <returns>true if operation was bound successfully; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComBinder.TryBindSetIndex(System.Dynamic.SetIndexBinder,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject[],System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject@)">
            <summary>
            Tries to perform binding of the dynamic set index operation.
            </summary>
            <param name="binder">An instance of the <see cref="T:System.Dynamic.SetIndexBinder"/> that represents the details of the dynamic operation.</param>
            <param name="instance">The target of the dynamic operation. </param>
            <param name="args">An array of <see cref="T:System.Dynamic.DynamicMetaObject"/> instances - arguments to the invoke member operation.</param>
            <param name="value">The <see cref="T:System.Dynamic.DynamicMetaObject"/> representing the value for the set index operation.</param>
            <param name="result">The new <see cref="T:System.Dynamic.DynamicMetaObject"/> representing the result of the binding.</param>
            <returns>true if operation was bound successfully; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComBinder.TryConvert(System.Dynamic.ConvertBinder,System.Dynamic.DynamicMetaObject,System.Dynamic.DynamicMetaObject@)">
            <summary>
            Tries to perform binding of the dynamic Convert operation.
            </summary>
            <param name="binder">An instance of the <see cref="T:System.Dynamic.ConvertBinder"/> that represents the details of the dynamic operation.</param>
            <param name="instance">The target of the dynamic operation.</param>
            <param name="result">The new <see cref="T:System.Dynamic.DynamicMetaObject"/> representing the result of the binding.</param>
            <returns>true if operation was bound successfully; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComBinder.GetDynamicMemberNames(System.Object)">
            <summary>
            Gets the member names associated with the object.
            This function can operate only with objects for which <see cref="M:Microsoft.Scripting.ComInterop.ComBinder.IsComObject(System.Object)"/> returns true.
            </summary>
            <param name="value">The object for which member names are requested.</param>
            <returns>The collection of member names.</returns>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComBinder.GetDynamicDataMemberNames(System.Object)">
            <summary>
            Gets the member names of the data-like members associated with the object.
            This function can operate only with objects for which <see cref="M:Microsoft.Scripting.ComInterop.ComBinder.IsComObject(System.Object)"/> returns true.
            </summary>
            <param name="value">The object for which member names are requested.</param>
            <returns>The collection of member names.</returns>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComBinder.GetDynamicDataMembers(System.Object,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Gets the data-like members and associated data for an object.
            This function can operate only with objects for which <see cref="M:Microsoft.Scripting.ComInterop.ComBinder.IsComObject(System.Object)"/> returns true.
            </summary>
            <param name="value">The object for which data members are requested.</param>
            <param name="names">The enumeration of names of data members for which to retrieve values.</param>
            <returns>The collection of pairs that represent data member's names and their data.</returns>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.ComBinder.ComGetMemberBinder">
            <summary>
            Special binder that indicates special semantics for COM GetMember operation.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.ComEventSink">
            <summary>
            This class implements an event sink for a particular RCW.
            Unlike the implementation of events in TlbImp'd assemblies,
            we will create only one event sink per RCW (theoretically RCW might have
            several ComEventSink evenk sinks - but all these implement different source intefaces).
            Each ComEventSink contains a list of ComEventSinkMethod objects - which represent
            a single method on the source interface an a multicast delegate to redirect 
            the calls. Notice that we are chaining multicast delegates so that same 
            ComEventSinkMedhod can invoke multiple event handlers).
            
            ComEventSink implements an IDisposable pattern to Unadvise from the connection point.
            Typically, when RCW is finalized the corresponding Dispose will be triggered by 
            ComEventSinksContainer finalizer. Notice that lifetime of ComEventSinksContainer
            is bound to the lifetime of the RCW. 
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.ComEventSink.ComEventSinkMethod">
            <summary>
            Contains a methods DISPID (in a string formatted of "[DISPID=N]"
            and a chained list of delegates to invoke
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.ComEventSinkProxy">
            <summary>
            ComEventSinkProxy class is responsible for handling QIs for sourceIid 
            on instances of ComEventSink.
            
            Background: When a COM even sink advises to a connection point it is 
            supposed to hand over the dispinterface. Now, some hosts will trust
            the COM client to pass the correct pointer, but some will not.
            E.g. Excel's implementation of Connection Points will not cause a
            QI on the pointer that has been passed, however Word will QI the
            pointer to return the required interface.
            
            ComEventSink does not, strongly speaking, implements the interface 
            that it claims to implement - it is just "faking" it by using IReflect.
            Thus, Word's QIs on the pointer passed to ICP::Advise would fail. To
            prevent this we take advangate of RealProxy's ability of
            "dressing up" like other classes and hence successfully respond to QIs 
            for interfaces that it does not really support( it is OK to say 
            "I implement this interface" for event sinks only since the common 
            practice is to use IDistpach.Invoke when calling into event sinks). 
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.ComEventSinksContainer">
            <summary>
            ComEventSinksContainer is just a regular list with a finalizer.
            This list is usually attached as a custom data for RCW object and 
            is finalized whenever RCW is finalized.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.IDispatchMethodIndices">
            <summary>
            Layout of the IDispatch vtable
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.ComInvokeAction">
            <summary>
            Invokes the object. If it falls back, just produce an error.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.SplatInvokeBinder">
            <summary>
            Splats the arguments to another nested dynamic site, which does the
            real invocation of the IDynamicMetaObjectProvider. 
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComInvokeBinder.MakeIDispatchInvokeTarget">
            <summary>
            Create a stub for the target of the optimized lopop.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComInvokeBinder.MakeArgumentExpressions">
            <summary>
            Gets expressions to access all the arguments. This includes the instance argument.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.ComObject">
            <summary>
            This is a helper class for runtime-callable-wrappers of COM instances. We create one instance of this type
            for every generic RCW instance.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComObject.ObjectToComObject(System.Object)">
            <summary>
            This is the factory method to get the ComObject corresponding to an RCW
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.ComParamDesc">
            <summary>
            The parameter description of a method defined in a type library
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComParamDesc.#ctor(System.Runtime.InteropServices.ComTypes.ELEMDESC@,System.String)">
            <summary>
            Creates a representation for the paramter of a COM method
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComParamDesc.#ctor(System.Runtime.InteropServices.ComTypes.ELEMDESC@)">
            <summary>
            Creates a representation for the return value of a COM method
            TODO: Return values should be represented by a different type
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.ComInterop.ComParamDesc.DefaultValue">
            <summary>
            DBNull.Value if there is no default value
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComRuntimeHelpers.GetITypeInfoFromIDispatch(Microsoft.Scripting.ComInterop.IDispatch,System.Boolean)">
            <summary>
            Look for typeinfo using IDispatch.GetTypeInfo
            </summary>
            <param name="dispatch"></param>
            <param name="throwIfMissingExpectedTypeInfo">
            Some COM objects just dont expose typeinfo. In these cases, this method will return null.
            Some COM objects do intend to expose typeinfo, but may not be able to do so if the type-library is not properly 
            registered. This will be considered as acceptable or as an error condition depending on throwIfMissingExpectedTypeInfo</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComRuntimeHelpers.CheckIfMissingTypeInfoIsExpected(System.Int32,System.Boolean)">
            <summary>
            This method should be called when typeinfo is not available for an object. The function
            will check if the typeinfo is expected to be missing. This can include error cases where
            the same error is guaranteed to happen all the time, on all machines, under all circumstances.
            In such cases, we just have to operate without the typeinfo.
            
            However, if accessing the typeinfo is failing in a transient way, we might want to throw
            an exception so that we will eagerly predictably indicate the problem.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.UnsafeMethods">
            <summary>
            This class contains methods that either cannot be expressed in C#, or which require writing unsafe code.
            Callers of these methods need to use them extremely carefully as incorrect use could cause GC-holes
            and other problems.
            </summary>
            
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.UnsafeMethods.AssertByrefPointsToStack(System.IntPtr)">
            <summary>
            Ensure that "value" is a local variable in some caller's frame. So converting
            the byref to an IntPtr is a safe operation. Alternatively, we could also allow 
            allowed "value"  to be a pinned object.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.UnsafeMethods.IUnknownReleaseDelegate">
            <summary>
            We will emit an indirect call to an unmanaged function pointer from the vtable of the given interface pointer. 
            This approach can take only ~300 instructions on x86 compared with ~900 for Marshal.Release. We are relying on 
            the JIT-compiler to do pinvoke-stub-inlining and calling the pinvoke target directly.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.UnsafeMethods.IDispatchInvokeDelegate">
            <summary>
            We will emit an indirect call to an unmanaged function pointer from the vtable of the given IDispatch interface pointer. 
            It is not possible to express this in C#. Using an indirect pinvoke call allows us to do our own marshalling. 
            We can allocate the Variant arguments cheaply on the stack. We are relying on the JIT-compiler to do 
            pinvoke-stub-inlining and calling the pinvoke target directly.
            The alternative of calling via a managed interface declaration of IDispatch would have a performance
            penalty of going through a CLR stub that would have to re-push the arguments on the stack, etc.
            Marshal.GetDelegateForFunctionPointer could be used here, but its too expensive (~2000 instructions on x86).
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.ComTypeLibDesc">
            <summary>
            Cached information from a TLB. Only information that is required is saved. CoClasses are used
            for event hookup. Enums are stored for accessing symbolic names from scripts. 
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComTypeLibDesc.CreateFromGuid(System.Guid)">
            <summary>
            Reads the latest registered type library for the corresponding GUID,
            reads definitions of CoClass'es and Enum's from this library
            and creates a IDynamicMetaObjectProvider that allows to instantiate coclasses
            and get actual values for the enums.
            </summary>
            <param name="typeLibGuid">Type Library Guid</param>
            <returns>ComTypeLibDesc object</returns>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.ComTypeLibDesc.CreateFromObject(System.Object)">
            <summary>
            Gets an ITypeLib object from OLE Automation compatible RCW ,
            reads definitions of CoClass'es and Enum's from this library
            and creates a IDynamicMetaObjectProvider that allows to instantiate coclasses
            and get actual values for the enums.
            </summary>
            <param name="rcw">OLE automation compatible RCW</param>
            <returns>ComTypeLibDesc object</returns>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.DispCallable">
            <summary>
            This represents a bound dispmember on a IDispatch object.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.ExcepInfo">
            <summary>
            This is similar to ComTypes.EXCEPINFO, but lets us do our own custom marshaling
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.IDispatchComObject">
            <summary>
            An object that implements IDispatch
            
            This currently has the following issues:
            1. If we prefer ComObjectWithTypeInfo over IDispatchComObject, then we will often not
               IDispatchComObject since implementations of IDispatch often rely on a registered type library. 
               If we prefer IDispatchComObject over ComObjectWithTypeInfo, users get a non-ideal experience.
            2. IDispatch cannot distinguish between properties and methods with 0 arguments (and non-0 
               default arguments?). So obj.foo() is ambiguous as it could mean invoking method foo, 
               or it could mean invoking the function pointer returned by property foo.
               We are attempting to find whether we need to call a method or a property by examining
               the ITypeInfo associated with the IDispatch. ITypeInfo tell's use what parameters the method
               expects, is it a method or a property, what is the default property of the object, how to 
               create an enumerator for collections etc.
            3. IronPython processes the signature and converts ref arguments into return values. 
               However, since the signature of a DispMethod is not available beforehand, this conversion 
               is not possible. There could be other signature conversions that may be affected. How does 
               VB6 deal with ref arguments and IDispatch?
               
            We also support events for IDispatch objects:
            Background:
            COM objects support events through a mechanism known as Connect Points.
            Connection Points are separate objects created off the actual COM 
            object (this is to prevent circular references between event sink
            and event source). When clients want to sink events generated  by 
            COM object they would implement callback interfaces (aka source 
            interfaces) and hand it over (advise) to the Connection Point. 
            
            Implementation details:
            When IDispatchComObject.TryGetMember request is received we first check
            whether the requested member is a property or a method. If this check
            fails we will try to determine whether an event is requested. To do 
            so we will do the following set of steps:
            1. Verify the COM object implements IConnectionPointContainer
            2. Attempt to find COM object's coclass's description
               a. Query the object for IProvideClassInfo interface. Go to 3, if found
               b. From object's IDispatch retrieve primary interface description
               c. Scan coclasses declared in object's type library.
               d. Find coclass implementing this particular primary interface 
            3. Scan coclass for all its source interfaces.
            4. Check whether to any of the methods on the source interfaces matches 
            the request name
            
            Once we determine that TryGetMember requests an event we will return
            an instance of BoundDispEvent class. This class has InPlaceAdd and
            InPlaceSubtract operators defined. Calling InPlaceAdd operator will:
            1. An instance of ComEventSinksContainer class is created (unless 
            RCW already had one). This instance is hanged off the RCW in attempt
            to bind the lifetime of event sinks to the lifetime of the RCW itself,
            meaning event sink will be collected once the RCW is collected (this
            is the same way event sinks lifetime is controlled by PIAs).
            Notice: ComEventSinksContainer contains a Finalizer which will go and
            unadvise all event sinks.
            Notice: ComEventSinksContainer is a list of ComEventSink objects. 
            2. Unless we have already created a ComEventSink for the required 
            source interface, we will create and advise a new ComEventSink. Each
            ComEventSink implements a single source interface that COM object 
            supports. 
            3. ComEventSink contains a map between method DISPIDs to  the 
            multicast delegate that will be invoked when the event is raised.
            4. ComEventSink implements IReflect interface which is exposed as
            custom IDispatch to COM consumers. This allows us to intercept calls
            to IDispatch.Invoke and apply custom logic - in particular we will
            just find and invoke the multicast delegate corresponding to the invoked
            dispid.
             </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.NullArgBuilder">
            <summary>
            ArgBuilder which always produces null.  
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.SimpleArgBuilder">
            <summary>
            SimpleArgBuilder produces the value produced by the user as the argument value.  It
            also tracks information about the original parameter and is used to create extended
            methods for params arrays and param dictionary functions.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.VarEnumSelector">
            <summary>
            If a managed user type (as opposed to a primitive type or a COM object) is passed as an argument to a COM call, we need
            to determine the VarEnum type we will marshal it as. We have the following options:
            1.	Raise an exception. Languages with their own version of primitive types would not be able to call
                COM methods using the language's types (for eg. strings in IronRuby are not System.String). An explicit
                cast would be needed.
            2.	We could marshal it as VT_DISPATCH. Then COM code will be able to access all the APIs in a late-bound manner,
                but old COM components will probably malfunction if they expect a primitive type.
            3.	We could guess which primitive type is the closest match. This will make COM components be as easily 
                accessible as .NET methods.
            4.	We could use the type library to check what the expected type is. However, the type library may not be available.
            
            VarEnumSelector implements option # 3
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.VarEnumSelector.GetManagedMarshalType(System.Runtime.InteropServices.VarEnum)">
            <summary>
            Gets the managed type that an object needs to be coverted to in order for it to be able
            to be represented as a Variant.
            
            In general, there is a many-to-many mapping between Type and VarEnum. However, this method
            returns a simple mapping that is needed for the current implementation. The reason for the 
            many-to-many relation is:
            1. Int32 maps to VT_I4 as well as VT_ERROR, and Decimal maps to VT_DECIMAL and VT_CY. However,
               this changes if you throw the wrapper types into the mix.
            2. There is no Type to represent COM types. __ComObject is a private type, and Object is too
               general.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.VarEnumSelector.CreateComPrimitiveTypeFamilies">
            <summary>
            Creates a family of COM types such that within each family, there is a completely non-lossy
            conversion from a type to an earlier type in the family.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.VarEnumSelector.GetConversionsToComPrimitiveTypeFamilies(System.Type)">
            <summary>
            Get the (one representative type for each) primitive type families that the argument can be converted to
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.VarEnumSelector.CheckForAmbiguousMatch(System.Type,System.Collections.Generic.List{System.Runtime.InteropServices.VarEnum})">
            <summary>
            If there is more than one type family that the argument can be converted to, we will throw a
            AmbiguousMatchException instead of randomly picking a winner.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.VarEnumSelector.TryGetPrimitiveComTypeViaConversion(System.Type,System.Runtime.InteropServices.VarEnum@)">
            <summary>
            Is there a unique primitive type that has the best conversion for the argument
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.VarEnumSelector.GetVariantBuilder(System.Type)">
            <summary>
            Get the COM Variant type that argument should be marshaled as for a call to COM
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.Variant">
            <summary>
            Variant is the basic COM type for late-binding. It can contain any other COM data type.
            This type definition precisely matches the unmanaged data layout so that the struct can be passed
            to and from COM calls.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.Variant.IsPrimitiveType(System.Runtime.InteropServices.VarEnum)">
            <summary>
            Primitive types are the basic COM types. It includes valuetypes like ints, but also reference types
            like BStrs. It does not include composite types like arrays and user-defined COM types (IUnknown/IDispatch).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.Variant.ToObject">
            <summary>
            Get the managed object representing the Variant.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.ComInterop.Variant.Clear">
            <summary>
            Release any unmanaged memory associated with the Variant
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Scripting.ComInterop.VariantBuilder">
            <summary>
            VariantBuilder handles packaging of arguments into a Variant for a call to IDispatch.Invoke
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Strings">
            <summary>
               Strongly-typed and parameterized string factory.
            </summary>
            <summary>
               Strongly-typed and parameterized string factory.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.ComObjectExpected">
            <summary>
            A string like  "COM object is expected."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.CannotCall">
            <summary>
            A string like  "Cannot perform call."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.COMObjectDoesNotSupportEvents">
            <summary>
            A string like  "COM object does not support events."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.COMObjectDoesNotSupportSourceInterface">
            <summary>
            A string like  "COM object does not support specified source interface."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.SetComObjectDataFailed">
            <summary>
            A string like  "Marshal.SetComObjectData failed."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MethodShouldNotBeCalled">
            <summary>
            A string like  "This method exists only to keep the compiler happy."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.UnexpectedVarEnum(System.Object)">
            <summary>
            A string like  "Unexpected VarEnum {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.DispBadParamCount(System.Object)">
            <summary>
            A string like  "Error while invoking {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.DispMemberNotFound(System.Object)">
            <summary>
            A string like  "Error while invoking {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.DispNoNamedArgs(System.Object)">
            <summary>
            A string like  "Error while invoking {0}. Named arguments are not supported."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.DispOverflow(System.Object)">
            <summary>
            A string like  "Error while invoking {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.DispTypeMismatch(System.Object,System.Object)">
            <summary>
            A string like  "Could not convert argument {0} for call to {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.DispParamNotOptional(System.Object)">
            <summary>
            A string like  "Error while invoking {0}. A required parameter was omitted."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.CannotRetrieveTypeInformation">
            <summary>
            A string like  "ResolveComReference.CannotRetrieveTypeInformation."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.GetIDsOfNamesInvalid(System.Object)">
            <summary>
            A string like  "IDispatch::GetIDsOfNames behaved unexpectedly for {0}."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.UnsupportedEnumType">
            <summary>
            A string like  "Attempting to wrap an unsupported enum type."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.UnsupportedHandlerType">
            <summary>
            A string like  "Attempting to pass an event handler of an unsupported type."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.CouldNotGetDispId(System.Object,System.Object)">
            <summary>
            A string like  "Could not get dispatch ID for {0} (error: {1})."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.AmbiguousConversion(System.Object,System.Object)">
            <summary>
            A string like  "There are valid conversions from {0} to {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.VariantGetAccessorNYI(System.Object)">
            <summary>
            A string like  "Variant.GetAccessor cannot handle {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.InvalidOperation_ContainsGenericParameters(System.Object,System.Object)">
            <summary>
            A string like  "Cannot access member {1} declared on type {0} because the type contains generic parameters."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.MissingType(System.Object)">
            <summary>
            A string like  "Type '{0}' is missing or cannot be loaded."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.StaticAccessFromInstanceError(System.Object,System.Object)">
            <summary>
            A string like  "static property "{0}" of "{1}" can only be read through a type, not an instance"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.StaticAssignmentFromInstanceError(System.Object,System.Object)">
            <summary>
            A string like  "static property "{0}" of "{1}" can only be assigned to through a type, not an instance"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MethodPreconditionViolated">
            <summary>
            A string like  "Method precondition violated"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.InvalidArgumentValue">
            <summary>
            A string like  "Invalid argument value"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.NonEmptyStringRequired">
            <summary>
            A string like  "Non-empty string required"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.NonEmptyCollectionRequired">
            <summary>
            A string like  "Non-empty collection required"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MustBeExceptionInstance">
            <summary>
            A string like  "must by an Exception instance"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.TypeOfTestMustBeBool">
            <summary>
            A string like  "Type of test must be bool"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.TypeOfExpressionMustBeBool">
            <summary>
            A string like  "Type of the expression must be bool"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.EmptyStringIsInvalidPath">
            <summary>
            A string like  "Empty string is not a valid path."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.InvalidDelegate">
            <summary>
            A string like  "Invalid delegate type (Invoke method not found)."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.ExpectedStaticProperty">
            <summary>
            A string like  "expected only static property"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.PropertyDoesNotExist">
            <summary>
            A string like  "Property doesn't exist on the provided type"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.FieldDoesNotExist">
            <summary>
            A string like  "Field doesn't exist on provided type"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.TypeDoesNotHaveConstructorForTheSignature">
            <summary>
            A string like  "Type doesn't have constructor with a given signature"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.TypeDoesNotHaveMethodForName">
            <summary>
            A string like  "Type doesn't have a method with a given name."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.TypeDoesNotHaveMethodForNameSignature">
            <summary>
            A string like  "Type doesn't have a method with a given name and signature."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.CountCannotBeNegative">
            <summary>
            A string like  "Count must be non-negative."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.ArrayTypeMustBeArray">
            <summary>
            A string like  "arrayType must be an array type"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MustHaveCodeOrTarget">
            <summary>
            A string like  "Either code or target must be specified."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.TypeParameterIsNotDelegate(System.Object)">
            <summary>
            A string like  "Type parameter is {0}. Expected a delegate."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.InvalidCast(System.Object,System.Object)">
            <summary>
            A string like  "Cannot cast from type '{0}' to type '{1}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.UnknownMemberType(System.Object)">
            <summary>
            A string like  "unknown member type: '{0}'. "
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.FirstArgumentMustBeCallSite">
            <summary>
            A string like  "RuleBuilder can only be used with delegates whose first argument is CallSite."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.NoInstanceForCall">
            <summary>
            A string like  "no instance for call."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MissingTest">
            <summary>
            A string like  "Missing Test."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MissingTarget">
            <summary>
            A string like  "Missing Target."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.NonGenericWithGenericGroup(System.Object)">
            <summary>
            A string like  "The operation requires a non-generic type for {0}, but this represents generic types only"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.InvalidOperation(System.Object)">
            <summary>
            A string like  "Invalid operation: '{0}'"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.FinallyAlreadyDefined">
            <summary>
            A string like  "Finally already defined."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.CannotHaveFaultAndFinally">
            <summary>
            A string like  "Can not have fault and finally."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.FaultAlreadyDefined">
            <summary>
            A string like  "Fault already defined."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.CantCreateDefaultTypeFor(System.Object)">
            <summary>
            A string like  "Cannot create default value for type {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.UnhandledConvert(System.Object)">
            <summary>
            A string like  "Unhandled convert: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.NoCallableMethods(System.Object,System.Object)">
            <summary>
            A string like  "{0}.{1} has no publiclly visible method."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.GlobalsMustBeUnique">
            <summary>
            A string like  "Global/top-level local variable names must be unique."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.GenNonSerializableBinder">
            <summary>
            A string like  "Generating code from non-serializable CallSiteBinder."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.InvalidPath">
            <summary>
            A string like  "Specified path is invalid."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.DictionaryNotHashable">
            <summary>
            A string like  "Dictionaries are not hashable."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.LanguageRegistered">
            <summary>
            A string like  "language already registered."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MethodOrOperatorNotImplemented">
            <summary>
            A string like  "The method or operation is not implemented."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.NoException">
            <summary>
            A string like  "No exception."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.ExtensionMustBePublic(System.Object)">
            <summary>
            A string like  "Extension type {0} must be public."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.AlreadyInitialized">
            <summary>
            A string like  "Already initialized."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.MustReturnScopeExtension">
            <summary>
            A string like  "CreateScopeExtension must return a scope extension."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.InvalidParamNumForService">
            <summary>
            A string like  "Invalid number of parameters for the service."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.InvalidArgumentType(System.Object,System.Object)">
            <summary>
            A string like  "Invalid type of argument {0}; expecting {1}."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.CannotChangeNonCachingValue">
            <summary>
            A string like  "Cannot change non-caching value."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.FieldReadonly(System.Object)">
            <summary>
            A string like  "Field {0} is read-only"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.PropertyReadonly(System.Object)">
            <summary>
            A string like  "Property {0} is read-only"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.UnexpectedEvent(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            A string like  "Expected event from {0}.{1}, got event from {2}.{3}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.ExpectedBoundEvent(System.Object)">
            <summary>
            A string like  "expected bound event, got {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.UnexpectedType(System.Object,System.Object)">
            <summary>
            A string like  "Expected type {0}, got {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.MemberWriteOnly(System.Object)">
            <summary>
            A string like  "can only write to member {0}."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.NoCodeToCompile">
            <summary>
            A string like  "No code to compile."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.InvalidStreamType(System.Object)">
            <summary>
            A string like  "Invalid stream type: {0}."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.QueueEmpty">
            <summary>
            A string like  "Queue empty."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.EnumerationNotStarted">
            <summary>
            A string like  "Enumeration has not started. Call MoveNext."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.EnumerationFinished">
            <summary>
            A string like  "Enumeration already finished."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.CantAddCasing(System.Object)">
            <summary>
            A string like  "can't add another casing for identifier {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.CantAddIdentifier(System.Object)">
            <summary>
            A string like  "can't add new identifier {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.InvalidCtorImplementation(System.Object,System.Object)">
            <summary>
            A string like  "Type '{0}' doesn't provide a suitable public constructor or its implementation is faulty: {1}"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.InvalidOutputDir">
            <summary>
            A string like  "Invalid output directory."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.InvalidAsmNameOrExtension">
            <summary>
            A string like  "Invalid assembly name or file extension."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.CanotEmitConstant(System.Object,System.Object)">
            <summary>
            A string like  "Cannot emit constant {0} ({1})"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.NoImplicitCast(System.Object,System.Object)">
            <summary>
            A string like  "No implicit cast from {0} to {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.NoExplicitCast(System.Object,System.Object)">
            <summary>
            A string like  "No explicit cast from {0} to {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.NameNotDefined(System.Object)">
            <summary>
            A string like  "name '{0}' not defined"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.NoDefaultValue">
            <summary>
            A string like  "No default value for a given type."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.UnknownLanguageProviderType">
            <summary>
            A string like  "Specified language provider type is not registered."
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.CantReadProperty">
            <summary>
            A string like  "can't read from property"
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Strings.CantWriteProperty">
            <summary>
            A string like  "can't write to property"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.IllegalNew_GenericParams(System.Object)">
            <summary>
            A string like  "Cannot create instance of {0} because it contains generic parameters"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Strings.VerificationException(System.Object,System.Object,System.Object)">
            <summary>
            A string like  "Non-verifiable assembly generated: {0}:\nAssembly preserved as {1}\nError text:\n{2}\n"
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Error">
            <summary>
               Strongly-typed and parameterized exception factory.
            </summary>
            <summary>
               Strongly-typed and parameterized exception factory.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.COMObjectDoesNotSupportEvents">
            <summary>
            ArgumentException with message like "COM object does not support events."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.COMObjectDoesNotSupportSourceInterface">
            <summary>
            ArgumentException with message like "COM object does not support specified source interface."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.SetComObjectDataFailed">
            <summary>
            InvalidOperationException with message like "Marshal.SetComObjectData failed."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.MethodShouldNotBeCalled">
            <summary>
            InvalidOperationException with message like "This method exists only to keep the compiler happy."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.UnexpectedVarEnum(System.Object)">
            <summary>
            InvalidOperationException with message like "Unexpected VarEnum {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.DispBadParamCount(System.Object)">
            <summary>
            System.Reflection.TargetParameterCountException with message like "Error while invoking {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.DispMemberNotFound(System.Object)">
            <summary>
            MissingMemberException with message like "Error while invoking {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.DispNoNamedArgs(System.Object)">
            <summary>
            ArgumentException with message like "Error while invoking {0}. Named arguments are not supported."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.DispOverflow(System.Object)">
            <summary>
            OverflowException with message like "Error while invoking {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.DispTypeMismatch(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Could not convert argument {0} for call to {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.DispParamNotOptional(System.Object)">
            <summary>
            ArgumentException with message like "Error while invoking {0}. A required parameter was omitted."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CannotRetrieveTypeInformation">
            <summary>
            InvalidOperationException with message like "ResolveComReference.CannotRetrieveTypeInformation."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.GetIDsOfNamesInvalid(System.Object)">
            <summary>
            ArgumentException with message like "IDispatch::GetIDsOfNames behaved unexpectedly for {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.UnsupportedEnumType">
            <summary>
            InvalidOperationException with message like "Attempting to wrap an unsupported enum type."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.UnsupportedHandlerType">
            <summary>
            InvalidOperationException with message like "Attempting to pass an event handler of an unsupported type."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CouldNotGetDispId(System.Object,System.Object)">
            <summary>
            MissingMemberException with message like "Could not get dispatch ID for {0} (error: {1})."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.AmbiguousConversion(System.Object,System.Object)">
            <summary>
            System.Reflection.AmbiguousMatchException with message like "There are valid conversions from {0} to {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.VariantGetAccessorNYI(System.Object)">
            <summary>
            NotImplementedException with message like "Variant.GetAccessor cannot handle {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.MustHaveCodeOrTarget">
            <summary>
            ArgumentException with message like "Either code or target must be specified."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.TypeParameterIsNotDelegate(System.Object)">
            <summary>
            InvalidOperationException with message like "Type parameter is {0}. Expected a delegate."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidCast(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "Cannot cast from type '{0}' to type '{1}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.UnknownMemberType(System.Object)">
            <summary>
            InvalidOperationException with message like "unknown member type: '{0}'. "
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.FirstArgumentMustBeCallSite">
            <summary>
            InvalidOperationException with message like "RuleBuilder can only be used with delegates whose first argument is CallSite."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoInstanceForCall">
            <summary>
            InvalidOperationException with message like "no instance for call."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.MissingTest">
            <summary>
            InvalidOperationException with message like "Missing Test."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.MissingTarget">
            <summary>
            InvalidOperationException with message like "Missing Target."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NonGenericWithGenericGroup(System.Object)">
            <summary>
            TypeLoadException with message like "The operation requires a non-generic type for {0}, but this represents generic types only"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidOperation(System.Object)">
            <summary>
            ArgumentException with message like "Invalid operation: '{0}'"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.FinallyAlreadyDefined">
            <summary>
            InvalidOperationException with message like "Finally already defined."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CannotHaveFaultAndFinally">
            <summary>
            InvalidOperationException with message like "Can not have fault and finally."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.FaultAlreadyDefined">
            <summary>
            InvalidOperationException with message like "Fault already defined."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CantCreateDefaultTypeFor(System.Object)">
            <summary>
            ArgumentException with message like "Cannot create default value for type {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.UnhandledConvert(System.Object)">
            <summary>
            ArgumentException with message like "Unhandled convert: {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoCallableMethods(System.Object,System.Object)">
            <summary>
            InvalidOperationException with message like "{0}.{1} has no publiclly visible method."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.GlobalsMustBeUnique">
            <summary>
            ArgumentException with message like "Global/top-level local variable names must be unique."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.GenNonSerializableBinder">
            <summary>
            ArgumentException with message like "Generating code from non-serializable CallSiteBinder."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidPath">
            <summary>
            ArgumentException with message like "Specified path is invalid."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.DictionaryNotHashable">
            <summary>
            ArgumentTypeException with message like "Dictionaries are not hashable."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.LanguageRegistered">
            <summary>
            InvalidOperationException with message like "language already registered."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.MethodOrOperatorNotImplemented">
            <summary>
            NotImplementedException with message like "The method or operation is not implemented."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoException">
            <summary>
            InvalidOperationException with message like "No exception."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.ExtensionMustBePublic(System.Object)">
            <summary>
            ArgumentException with message like "Extension type {0} must be public."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.AlreadyInitialized">
            <summary>
            InvalidOperationException with message like "Already initialized."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.MustReturnScopeExtension">
            <summary>
            InvalidImplementationException with message like "CreateScopeExtension must return a scope extension."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidParamNumForService">
            <summary>
            ArgumentException with message like "Invalid number of parameters for the service."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidArgumentType(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Invalid type of argument {0}; expecting {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CannotChangeNonCachingValue">
            <summary>
            ArgumentException with message like "Cannot change non-caching value."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.FieldReadonly(System.Object)">
            <summary>
            MissingMemberException with message like "Field {0} is read-only"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.PropertyReadonly(System.Object)">
            <summary>
            MissingMemberException with message like "Property {0} is read-only"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.UnexpectedEvent(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Expected event from {0}.{1}, got event from {2}.{3}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.ExpectedBoundEvent(System.Object)">
            <summary>
            ArgumentTypeException with message like "expected bound event, got {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.UnexpectedType(System.Object,System.Object)">
            <summary>
            ArgumentTypeException with message like "Expected type {0}, got {1}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.MemberWriteOnly(System.Object)">
            <summary>
            MemberAccessException with message like "can only write to member {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoCodeToCompile">
            <summary>
            InvalidOperationException with message like "No code to compile."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidStreamType(System.Object)">
            <summary>
            ArgumentException with message like "Invalid stream type: {0}."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.QueueEmpty">
            <summary>
            InvalidOperationException with message like "Queue empty."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.EnumerationNotStarted">
            <summary>
            InvalidOperationException with message like "Enumeration has not started. Call MoveNext."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.EnumerationFinished">
            <summary>
            InvalidOperationException with message like "Enumeration already finished."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CantAddCasing(System.Object)">
            <summary>
            InvalidOperationException with message like "can't add another casing for identifier {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CantAddIdentifier(System.Object)">
            <summary>
            InvalidOperationException with message like "can't add new identifier {0}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidOutputDir">
            <summary>
            ArgumentException with message like "Invalid output directory."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.InvalidAsmNameOrExtension">
            <summary>
            ArgumentException with message like "Invalid assembly name or file extension."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CanotEmitConstant(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "Cannot emit constant {0} ({1})"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoImplicitCast(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "No implicit cast from {0} to {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoExplicitCast(System.Object,System.Object)">
            <summary>
            ArgumentException with message like "No explicit cast from {0} to {1}"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NameNotDefined(System.Object)">
            <summary>
            MissingMemberException with message like "name '{0}' not defined"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.NoDefaultValue">
            <summary>
            ArgumentException with message like "No default value for a given type."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.UnknownLanguageProviderType">
            <summary>
            ArgumentException with message like "Specified language provider type is not registered."
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CantReadProperty">
            <summary>
            InvalidOperationException with message like "can't read from property"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.CantWriteProperty">
            <summary>
            InvalidOperationException with message like "can't write to property"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.IllegalNew_GenericParams(System.Object)">
            <summary>
            ArgumentException with message like "Cannot create instance of {0} because it contains generic parameters"
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Error.VerificationException(System.Object,System.Object,System.Object)">
            <summary>
            System.Security.VerificationException with message like "Non-verifiable assembly generated: {0}:\nAssembly preserved as {1}\nError text:\n{2}\n"
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.CompilerServices.DebugLambdaInfo">
            <summary>
            Used by compilers to provide additional debug information about LambdaExpression to DebugContext
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.CompilerServices.IDebugCompilerSupport">
            <summary>
            Implemented by compilers to allow the traceback engine to get additional information.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.CompilerServices.DebugContext">
            <summary>
            Provides services to compilers for instrumenting code with tracebacks.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Debugging.CompilerServices.DebugContext.CreateInstance">
            <summary>
            Creates a new instance of DebugContext
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Debugging.CompilerServices.DebugContext.TransformLambda(System.Linq.Expressions.LambdaExpression,Microsoft.Scripting.Debugging.CompilerServices.DebugLambdaInfo)">
            <summary>
            Transforms a LambdaExpression to a debuggable LambdaExpression
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Debugging.CompilerServices.DebugContext.TransformLambda(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Transforms a LambdaExpression to a debuggable LambdaExpression
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Debugging.CompilerServices.DebugContext.ResetSourceFile(System.String)">
            <summary>
            Resets a state associated with a source file that's maintained in the DebugContext
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.CompilerServices.DebugContext.Threads">
            <summary>
            Threads
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.CompilerServices.DebugContext.DebugCallback">
            <summary>
            Hook
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.DebugFrame.Thread">
            <summary>
            Thread
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.DebugFrame.StackDepth">
            <summary>
            FrameOrder
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.DebugFrame.Variables">
            <summary>
            Variables
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.DebugFrame.CurrentSequencePointIndex">
            <summary>
            CurrentSequencePointIndex
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Debugging.DebugFrame.ReplaceLiftedLocals(System.Runtime.CompilerServices.IRuntimeVariables)">
            <summary>
            // This method is called from the generator to update the frame with generator's locals
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Debugging.DebugFrame.RemapToGenerator(System.Int32)">
            <summary>
            Remaps the frame's state to use the generator for execution.
            </summary>
            <param name="version">Int32.MaxValue to map to latest version</param>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.DebuggableLambdaBuilder">
            <summary>
            DebuggableLambdaBuilder is used to transform a DLR expression tree into a debuggable lambda expression.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.DebugGenerator`1">
            <summary>
            Used to wrap a lambda that was already a generator prior to transform.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.DebugInfoRewriter">
            <summary>
            Used to rewrite expressions containing DebugInfoExpressions.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.DebugSourceSpan">
            <summary>
            Combines source file and span.  Also provides Contains and Intersects functionality.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.DebugRuntimeVariables">
            <summary>
            Implementation of IDebugRuntimeVariables, which wraps IRuntimeVariables + FunctionInfo/DebugMarker
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.DefaultDebugThread">
            <summary>
            Default implementation of BaseDebugThread, which uses DLR's RuntimeVariablesExpression for lifting locals.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.DefaultDebugThreadFactory">
            <summary>
            Default implementation of IDebugThreadFactory, which uses DLR's RuntimeVariablesExpression for lifting locals.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.FunctionInfo.SequencePoints">
            <summary>
            SequencePoints
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.FunctionInfo.Name">
            <summary>
            Gets the name.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.FunctionInfo.CustomPayload">
            <summary>
            Gets the custom payload.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Debugging.FunctionInfo.GetTraceLocations">
            <summary>
            GetTraceLocations
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Debugging.IDebugCallback.OnDebugEvent(Microsoft.Scripting.Debugging.TraceEventKind,Microsoft.Scripting.Debugging.DebugThread,Microsoft.Scripting.Debugging.FunctionInfo,System.Int32,System.Int32,System.Object)">
            <summary>
            Callback that is fired by the traceback engine
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.LambdaWalker">
            <summary>
            Used to extract locals information from expressions.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.ErrorStrings">
            <summary>
               Strongly-typed and parameterized string factory.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.IDebugRuntimeVariables">
            <summary>
            IDebugRuntimeVariables is used to wrap IRuntimeVariables and add properties for retrieving
            FunctionInfo and DebugMarker from debuggable labmdas.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.IDebugThreadFactory">
            <summary>
            IDebugThreadFactory is used to abstract how frames and local variables are maintained at run/debug time.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.ScopedRuntimeVariables">
            <summary>
            Implements IRuntimeVariables in a way that preserves scoping within the lambda.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.TracePipeline">
            <summary>
            TraceSession.
            
            Basically holds a list of last encountered DebugFrame instances 
            (one per running thread).
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Debugging.VariableInfo">
            <summary>
            Used to provide information about locals/parameters at debug time.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Debugging.VariableInfo._localIndex">
            <summary>
            Index within byref variables list or within strongbox variables list.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Debugging.VariableInfo._globalIndex">
            <summary>
            Index within the combined list.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.VariableInfo.VariableType">
            <summary>
            Gets the variable type.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.VariableInfo.Name">
            <summary>
            Gets the name.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Debugging.VariableInfo.IsParameter">
            <summary>
            Gets or sets a value indicating whether it is a parameter.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.DebugOptions">
            <summary>
            This class holds onto internal debugging options used in this assembly. 
            These options can be set via environment variables DLR_{option-name}.
            Boolean options map "true" to true and other values to false.
            
            These options are for internal debugging only, and should not be
            exposed through any public APIs.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.IsConstructor(System.Reflection.MethodBase)">
            <summary>
            True if the MethodBase is method which is going to construct an object
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.GetType(System.Object)">
            <summary>
            Returns the System.Type for any object, including null.  The type of null
            is represented by None.Type and all other objects just return the 
            result of Object.GetType
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.GetTypes(System.Object[])">
            <summary>
            Simply returns a Type[] from calling GetType on each element of args.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.TypesEqual(System.Collections.IList,System.Int32,System.Type[])">
            <summary>
            EMITTED
            Used by default method binder to check types of splatted arguments.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.TryGetCallableMethod(System.Type,System.Reflection.MethodInfo)">
            <summary>
            Given a MethodInfo which may be declared on a non-public type this attempts to
            return a MethodInfo which will dispatch to the original MethodInfo but is declared
            on a public type.
            
            Returns the original method if the method if a public version cannot be found.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.FilterNonVisibleMembers(System.Type,System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
            <summary>
            Non-public types can have public members that we find when calling type.GetMember(...).  This
            filters out the non-visible members by attempting to resolve them to the correct visible type.
            
            If no correct visible type can be found then the member is not visible and we won't call it.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.MemberEquals(System.Reflection.MemberInfo,System.Reflection.MemberInfo)">
            <summary>
            Sees if two MemberInfos point to the same underlying construct in IL.  This
            ignores the ReflectedType property which exists on MemberInfos which
            causes direct comparisons to be false even if they are the same member.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.GetTryConvertReturnValue(System.Type)">
            <summary>
            Returns a value which indicates failure when a OldConvertToAction of ImplicitTry or
            ExplicitTry.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.LightCompile(System.Linq.Expressions.LambdaExpression)">
            <summary>
            Creates an interpreted delegate for the lambda.
            </summary>
            <param name="lambda">The lambda to compile.</param>
            <returns>A delegate which can interpret the lambda.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.LightCompile(System.Linq.Expressions.LambdaExpression,System.Int32)">
            <summary>
            Creates an interpreted delegate for the lambda.
            </summary>
            <param name="lambda">The lambda to compile.</param>
            <param name="compilationThreshold">The number of iterations before the interpreter starts compiling</param>
            <returns>A delegate which can interpret the lambda.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.LightCompile``1(System.Linq.Expressions.Expression{``0})">
            <summary>
            Creates an interpreted delegate for the lambda.
            </summary>
            <typeparam name="T">The lambda's delegate type.</typeparam>
            <param name="lambda">The lambda to compile.</param>
            <returns>A delegate which can interpret the lambda.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.LightCompile``1(System.Linq.Expressions.Expression{``0},System.Int32)">
            <summary>
            Creates an interpreted delegate for the lambda.
            </summary>
            <param name="lambda">The lambda to compile.</param>
            <param name="compilationThreshold">The number of iterations before the interpreter starts compiling</param>
            <returns>A delegate which can interpret the lambda.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.CompileToMethod(System.Linq.Expressions.LambdaExpression,System.Reflection.Emit.MethodBuilder,System.Boolean)">
            <summary>
            Compiles the lambda into a method definition.
            </summary>
            <param name="lambda">the lambda to compile</param>
            <param name="method">A <see cref="T:System.Reflection.Emit.MethodBuilder"/> which will be used to hold the lambda's IL.</param>
            <param name="emitDebugSymbols">A parameter that indicates if debugging information should be emitted to a PDB symbol store.</param>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.Compile``1(System.Linq.Expressions.Expression{``0},System.Boolean)">
            <summary>
            Compiles the LambdaExpression.
            
            If the lambda is compiled with emitDebugSymbols, it will be
            generated into a TypeBuilder. Otherwise, this method is the same as
            calling LambdaExpression.Compile()
            
            This is a workaround for a CLR limitiation: DynamicMethods cannot
            have debugging information.
            </summary>
            <param name="lambda">the lambda to compile</param>
            <param name="emitDebugSymbols">true to generate a debuggable method, false otherwise</param>
            <returns>the compiled delegate</returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.CompileToMethod``1(System.Linq.Expressions.Expression{``0},System.Runtime.CompilerServices.DebugInfoGenerator,System.Boolean)">
            <summary>
            Compiles the LambdaExpression, emitting it into a new type, and
            optionally making it debuggable.
            
            This is a workaround for a CLR limitiation: DynamicMethods cannot
            have debugging information.
            </summary>
            <param name="lambda">the lambda to compile</param>
            <param name="debugInfoGenerator">Debugging information generator used by the compiler to mark sequence points and annotate local variables.</param>
            <param name="emitDebugSymbols">True if debug symbols (PDBs) are emitted by the <paramref name="debugInfoGenerator"/>.</param>
            <returns>the compiled delegate</returns>
        </member>
        <member name="T:Microsoft.Scripting.Generation.CompilerHelpers.DebuggableCodeRewriter">
            <summary>
            Removes all live objects and places them in static fields of a type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.CompilerHelpers.Reduce(System.Linq.Expressions.DynamicExpression)">
            <summary>
            Reduces the provided DynamicExpression into site.Target(site, *args).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ConstantCheck.Check(System.Linq.Expressions.Expression,System.Object)">
            <summary>
            Tests to see if the expression is a constant with the given value.
            </summary>
            <param name="expression">The expression to examine</param>
            <param name="value">The constant value to check for.</param>
            <returns>true/false</returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ConstantCheck.IsConstant(System.Linq.Expressions.Expression,System.Object)">
            <summary>
            Tests to see if the expression is a constant with the given value.
            </summary>
            <param name="e">The expression to examine</param>
            <param name="value">The constant value to check for.</param>
            <returns>true/false</returns>
        </member>
        <member name="T:Microsoft.Scripting.Generation.FieldBuilderExpression">
            <summary>
            Provides a simple expression which enables embedding FieldBuilder's
            in an AST before the type is complete.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginCatchBlock(System.Type)">
            <summary>
            Begins a catch block.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginExceptFilterBlock">
            <summary>
            Begins an exception block for a filtered exception.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginExceptionBlock">
            <summary>
            Begins an exception block for a non-filtered exception.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginFaultBlock">
            <summary>
            Begins an exception fault block
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginFinallyBlock">
            <summary>
            Begins a finally block
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EndExceptionBlock">
            <summary>
            Ends an exception block.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.BeginScope">
            <summary>
            Begins a lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EndScope">
            <summary>
            Ends a lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.DeclareLocal(System.Type)">
            <summary>
            Declares a local variable of the specified type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.DeclareLocal(System.Type,System.Boolean)">
            <summary>
            Declares a local variable of the specified type, optionally
            pinning the object referred to by the variable.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.DefineLabel">
            <summary>
            Declares a new label.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.MarkLabel(System.Reflection.Emit.Label)">
            <summary>
            Marks the label at the current position.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode)">
            <summary>
            Emits an instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Byte)">
            <summary>
            Emits an instruction with a byte argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.ConstructorInfo)">
            <summary>
            Emits an instruction with the metadata token for the specified contructor.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Double)">
            <summary>
            Emits an instruction with a double argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.FieldInfo)">
            <summary>
            Emits an instruction with the metadata token for the specified field.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Single)">
            <summary>
            Emits an instruction with a float argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int32)">
            <summary>
            Emits an instruction with an int argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label)">
            <summary>
            Emits an instruction with a label argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.Label[])">
            <summary>
            Emits an instruction with multiple target labels (switch).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.LocalBuilder)">
            <summary>
            Emits an instruction with a reference to a local variable.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int64)">
            <summary>
            Emits an instruction with a long argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo)">
            <summary>
            Emits an instruction with the metadata token for a specified method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.SByte)">
            <summary>
            Emits an instruction with a signed byte argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Int16)">
            <summary>
            Emits an instruction with a short argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Reflection.Emit.SignatureHelper)">
            <summary>
            Emits an instruction with a signature token.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.String)">
            <summary>
            Emits an instruction with a string argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.Emit(System.Reflection.Emit.OpCode,System.Type)">
            <summary>
            Emits an instruction with the metadata token for a specified type argument.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitCall(System.Reflection.Emit.OpCode,System.Reflection.MethodInfo,System.Type[])">
            <summary>
            Emits a call or a virtual call to the varargs method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitCalli(System.Reflection.Emit.OpCode,System.Runtime.InteropServices.CallingConvention,System.Type,System.Type[])">
            <summary>
            Emits an unmanaged indirect call instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitCalli(System.Reflection.Emit.OpCode,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[])">
            <summary>
            Emits a managed indirect call instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.MarkSequencePoint(System.Diagnostics.SymbolStore.ISymbolDocumentWriter,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Marks a sequence point.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.UsingNamespace(System.String)">
            <summary>
            Specifies the namespace to be used in evaluating locals and watches for the
                current active lexical scope.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitLoadValueIndirect(System.Type)">
            <summary>
            Emits a Ldind* instruction for the appropriate type
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitStoreValueIndirect(System.Type)">
            <summary>
            Emits a Stind* instruction for the appropriate type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitStoreElement(System.Type)">
            <summary>
            Emits a Stelem* instruction for the appropriate type.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitBoxing(System.Type)">
            <summary>
            Boxes the value of the stack. No-op for reference types. Void is
            converted to a null reference. For almost all value types this
            method will box them in the standard way. Int32 and Boolean are
            handled with optimized conversions that reuse the same object for
            small values. For Int32 this is purely a performance optimization.
            For Boolean this is use to ensure that True and False are always
            the same objects.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitArray``1(System.Collections.Generic.IList{``0})">
            <summary>
            Emits an array of constant values provided in the given list.
            The array is strongly typed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitArray(System.Type,System.Int32,Microsoft.Scripting.Generation.EmitArrayHelper)">
            <summary>
            Emits an array of values of count size.  The items are emitted via the callback
            which is provided with the current item index to emit.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitArray(System.Type)">
            <summary>
            Emits an array construction code.  
            The code assumes that bounds for all dimensions
            are already emitted.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Generation.ILGen.EmitDefault(System.Type)">
            <summary>
            Emits default(T)
            Semantics match C# compiler behavior
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.KeyedQueue`2">
            <summary>
            A simple dictionary of queues, keyed off a particular type
            This is useful for storing free lists of variables
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.MethodSignatureInfo">
            <summary>
            Helper class to remove methods w/ identical signatures.  Used for GetDefaultMembers
            which returns members from all types in the hierarchy.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Generation.Snippets.SnippetsDirectory">
            <summary>
            Directory where snippet assembly will be saved if SaveSnippets is set.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Generation.Snippets.SaveSnippets">
            <summary>
            Save snippets to an assembly (see also SnippetsDirectory, SnippetsFileName).
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Generation.ToDiskRewriter">
            <summary>
            Serializes constants and dynamic sites so the code can be saved to disk
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Generation.TypeGen.TypeInitializer">
            <summary>
            Gets the Compiler associated with the Type Initializer (cctor) creating it if necessary.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.CommandLine">
            <summary>
            Command line hosting service.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.Shell.CommandLine.Scope">
            <summary>
            Scope is not remotable, and this only works in the same AppDomain.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.CommandLine.Run(Microsoft.Scripting.Hosting.ScriptEngine,Microsoft.Scripting.Hosting.Shell.IConsole,Microsoft.Scripting.Hosting.Shell.ConsoleOptions)">
            <summary>
            Executes the comand line - depending upon the options provided we will
            either run a single file, a single command, or enter the interactive loop.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.CommandLine.Run">
            <summary>
            Runs the command line.  Languages can override this to provide custom behavior other than:
                1. Running a single command
                2. Running a file
                3. Entering the interactive console loop.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.CommandLine.RunFile(Microsoft.Scripting.Hosting.ScriptSource)">
            <summary>
            Runs the specified filename
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.CommandLine.RunInteractive">
            <summary>
            Starts the interactive loop.  Performs any initialization necessary before
            starting the loop and then calls RunInteractiveLoop to start the loop.
            
            Returns the exit code when the interactive loop is completed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.CommandLine.RunInteractiveLoop">
            <summary>
            Runs the interactive loop.  Repeatedly parse and run interactive actions
            until an exit code is received.  If any exceptions are unhandled displays
            them to the console
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.CommandLine.TryInteractiveAction">
            <summary>
            Attempts to run a single interaction and handle any language-specific
            exceptions.  Base classes can override this and call the base implementation
            surrounded with their own exception handling.
            
            Returns null if successful and execution should continue, or an exit code.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.CommandLine.RunOneInteraction">
            <summary>
            Parses a single interactive command or a set of statements and executes it.
            
            Returns null if successful and execution should continue, or the appropiate exit code.
            
            We check if the code read is an interactive command or statements is by checking for NewLine
            If the code contains NewLine, it's a set of statements (most probably from SendToConsole)
            If the code does not contain a NewLine, it's an interactive command typed by the user at the prompt
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.CommandLine.TreatAsBlankLine(System.String,System.Int32)">
            <summary>
            Private helper function to see if we should treat the current input as a blank link.
            
            We do this if we only have auto-indent text.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.CommandLine.ReadStatement(System.Boolean@)">
            <summary>
            Read a statement, which can potentially be a multiple-line statement suite (like a class declaration).
            </summary>
            <param name="continueInteraction">Should the console session continue, or did the user indicate 
            that it should be terminated?</param>
            <returns>Expression to evaluate. null for empty input</returns>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.CommandLine.GetNextAutoIndentSize(System.String)">
            <summary>
            Gets the next level for auto-indentation
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.ConsoleHost">
            <summary>
            Core functionality to implement an interactive console. This should be derived for concrete implementations
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.Shell.ConsoleHost.ExeName">
            <summary>
            Console Host entry-point .exe name.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.ConsoleHost.Terminate(System.Int32)">
            <summary>
            Request (from another thread) the console REPL loop to terminate
            </summary>
            <param name="exitCode">The caller can specify the exitCode corresponding to the event triggering
            the termination. This will be returned from CommandLine.Run</param>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.ConsoleHost.Run(System.String[])">
            <summary>
            To be called from entry point.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.ConsoleHostOptionsParser.Parse(System.String[])">
            <exception cref="T:Microsoft.Scripting.Hosting.Shell.InvalidOptionException"></exception>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.ConsoleHostOptionsParser.ParseOption(System.String,System.String@,System.String@)">
            <summary>
            name == null means that the argument doesn't specify an option; the value contains the entire argument
            name == "" means that the option name is empty (argument separator); the value is null then
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.Shell.ConsoleOptions.Command">
            <summary>
            Literal script command given using -c option
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.Shell.ConsoleOptions.FileName">
            <summary>
            Filename to execute passed on the command line options.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Hosting.Shell.ConsoleOptions.PrintVersion">
            <summary>
            Only print the version of the script interpreter and exit
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.ICommandDispatcher">
            <summary>
            Used to dispatch a single interactive command. It can be used to control things like which Thread
            the command is executed on, how long the command is allowed to execute, etc
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.IConsole">
            <summary>
            Handles input and output for the console. It is comparable to System.IO.TextReader, 
            System.IO.TextWriter, System.Console, etc
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.IConsole.ReadLine(System.Int32)">
            <summary>
            Read a single line of interactive input, or a block of multi-line statements.
            
            An event-driven GUI console can implement this method by creating a thread that
            blocks and waits for an event indicating that input is available
            </summary>
            <param name="autoIndentSize">The indentation level to be used for the current suite of a compound statement.
            The console can ignore this argument if it does not want to support auto-indentation</param>
            <returns>null if the input stream has been closed. A string with a command to execute otherwise.
            It can be a multi-line string which should be processed as block of statements
            </returns>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.OptionsParser.Parse(System.String[],Microsoft.Scripting.Hosting.ScriptRuntimeSetup,Microsoft.Scripting.Hosting.LanguageSetup,Microsoft.Scripting.PlatformAdaptationLayer)">
            <exception cref="T:Microsoft.Scripting.Hosting.Shell.InvalidOptionException">On error.</exception>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.Remote.ConsoleRestartManager">
             <summary>
             Supports detecting the remote runtime being killed, and starting up a new one.
             
             Threading model:
             
             ConsoleRestartManager creates a separate thread on which to create and execute the consoles. 
             There are usually atleast three threads involved:
             
             1. Main app thread: Instantiates ConsoleRestartManager and accesses its APIs. This thread has to stay 
                responsive to user input and so the ConsoleRestartManager APIs cannot be long-running or blocking.
                Since the remote runtime process can terminate asynchronously, the current RemoteConsoleHost can 
                change at any time (if auto-restart is enabled). The app should typically not care which instance of 
                RemoteConsoleHost is currently being used. The flowchart of this thread is:
                    Create ConsoleRestartManager
                    ConsoleRestartManager.Start
                    Loop:
                        Respond to user input | Send user input to console for execution | BreakExecution | RestartConsole | GetMemberNames
                    ConsoleRestartManager.Terminate
                TODO: Currently, BreakExecution and GetMemberNames are called by the main thread synchronously.
                Since they execute code in the remote runtime, they could take arbitrarily long. We should change
                this so that the main app thread can never be blocked indefinitely.
            
             2. Console thread: Dedicated thread for creating RemoteConsoleHosts and executing code (which could
                take a long time or block indefinitely).
                    Wait for ConsoleRestartManager.Start to be called
                    Loop:
                        Create RemoteConsoleHost
                        Wait for signal for:
                             Execute code | RestartConsole | Process.Exited
            
             3. CompletionPort async callbacks:
                    Process.Exited | Process.OutputDataReceived | Process.ErrorDataReceived
             
             4. Finalizer thred
                Some objects may have a Finalize method (which possibly calls Dispose). Not many (if any) types
                should have a Finalize method.
             
             </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.Remote.ConsoleRestartManager._accessLock">
            <summary>
            Accessing _remoteConsoleHost from a thread other than console thread can result in race.
            If _remoteConsoleHost is accessed while holding _accessLock, it is guaranteed to be
            null or non-disposed.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.Remote.ConsoleRestartManager.#ctor(System.Boolean)">
            <summary>
            This is created on the "creating thread", and goes on standby. Start needs to be called for activation.
            </summary>
            <param name="exitOnNormalExit">A host might want one of two behaviors:
            1. Keep the REPL loop alive indefinitely, even when a specific instance of the RemoteConsoleHost terminates normally
            2. Close the REPL loop when an instance of the RemoteConsoleHost terminates normally, and restart the loop
               only if the instance terminates abnormally.</param>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.Remote.ConsoleRestartManager.Start">
            <summary>
            Needs to be called for activation.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.Remote.ConsoleRestartManager.Terminate">
            <summary>
            Request (from another thread) the console REPL loop to terminate
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.Remote.RemoteCommandDispatcher">
            <summary>
            This allows the RemoteConsoleHost to abort a long-running operation. The RemoteConsoleHost itself
            does not know which ThreadPool thread might be processing the remote call, and so it needs
            cooperation from the remote runtime server.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.Remote.RemoteCommandDispatcher.OutputCompleteMarker">
            <summary>
            Since OnOutputDataReceived is sent async, it can arrive late. The remote console
            cannot know if all output from the current command has been received. So
            RemoteCommandDispatcher writes out a marker to indicate the end of the output
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.Remote.RemoteCommandDispatcher.AbortCommand">
            <summary>
            Aborts the current active call to Execute by doing Thread.Abort
            </summary>
            <returns>true if a Thread.Abort was actually called. false if there is no active call to Execute</returns>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.Remote.RemoteConsoleCommandLine">
            <summary>
            Customize the CommandLine for remote scenarios
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.Remote.RemoteConsoleCommandLine.RemoteConsoleCommandDispatcher">
            <summary>
            CommandDispatcher to ensure synchronize output from the remote runtime
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.Remote.RemoteConsoleHost">
            <summary>
            ConsoleHost where the ScriptRuntime is hosted in a separate process (referred to as the remote runtime server)
            
            The RemoteConsoleHost spawns the remote runtime server and specifies an IPC channel name to use to communicate
            with each other. The remote runtime server creates and initializes a ScriptRuntime and a ScriptEngine, and publishes
            it over the specified IPC channel at a well-known URI. Note that the RemoteConsoleHost cannot easily participate
            in the initialization of the ScriptEngine as classes like LanguageContext are not remotable.
            
            The RemoteConsoleHost then starts the interactive loop and executes commands on the ScriptEngine over the remoting channel.
            The RemoteConsoleHost listens to stdout of the remote runtime server and echos it locally to the user.
            </summary>
        </member>
        <member name="E:Microsoft.Scripting.Hosting.Shell.Remote.RemoteConsoleHost.RemoteRuntimeExited">
            <summary>
            Called if the remote runtime process exits by itself. ie. without the remote console killing it.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.Remote.RemoteConsoleHost.CustomizeRemoteRuntimeStartInfo(System.Diagnostics.ProcessStartInfo)">
            <summary>
            Allows the console to customize the environment variables, working directory, etc.
            </summary>
            <param name="processInfo">At the least, processInfo.FileName should be initialized</param>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.Remote.RemoteConsoleHost.AbortCommand">
            <summary>
            Aborts the current active call to Execute by doing Thread.Abort
            </summary>
            <returns>true if a Thread.Abort was actually called. false if there is no active call to Execute</returns>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.Remote.RemoteRuntimeServer">
            <summary>
            The remote runtime server uses this class to publish an initialized ScriptEngine and ScriptRuntime 
            over a remoting channel.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.Remote.RemoteRuntimeServer.StartServer(System.String,Microsoft.Scripting.Hosting.ScriptScope)">
            <summary>
            Publish objects so that the host can use it, and then block indefinitely (until the input stream is open).
            
            Note that we should publish only one object, and then have other objects be accessible from it. Publishing
            multiple objects can cause problems if the client does a call like "remoteProxy1(remoteProxy2)" as remoting
            will not be able to know if the server object for both the proxies is on the same server.
            </summary>
            <param name="remoteRuntimeChannelName">The IPC channel that the remote console expects to use to communicate with the ScriptEngine</param>
            <param name="scope">A intialized ScriptScope that is ready to start processing script commands</param>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.SuperConsole.History">
            <summary>
            Class managing the command history.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.SuperConsole.SuperConsoleOptions">
            <summary>
            List of available options
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Hosting.Shell.SuperConsole.Cursor">
            <summary>
            Cursor position management
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.SuperConsole.Cursor._anchorTop">
            <summary>
            Beginning position of the cursor - top coordinate.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.SuperConsole.Cursor._anchorLeft">
            <summary>
            Beginning position of the cursor - left coordinate.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.SuperConsole._input">
            <summary>
            The console input buffer.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.SuperConsole._current">
            <summary>
            Current position - index into the input buffer
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.SuperConsole._autoIndentSize">
            <summary>
            The number of white-spaces displayed for the auto-indenation of the current line
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.SuperConsole._rendered">
            <summary>
            Length of the output currently rendered on screen.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.SuperConsole._history">
            <summary>
            Command history
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.SuperConsole._options">
            <summary>
            Tab options available in current context
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.SuperConsole._cursor">
            <summary>
            Cursort anchor - position of cursor when the routine was called
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Hosting.Shell.SuperConsole._commandLine">
            <summary>
            The command line that this console is attached to.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.SuperConsole.DisplayNextOption(System.ConsoleKeyInfo,System.Boolean)">
            <summary>
            Displays the next option in the option list,
            or beeps if no options available for current input prefix.
            If no input prefix, simply print tab.
            </summary>
            <param name="key"></param>
            <param name="prefix"></param>
        </member>
        <member name="M:Microsoft.Scripting.Hosting.Shell.SuperConsole.OnEnter(System.Boolean)">
            <summary>
            Handle the enter key. Adds the current input (if not empty) to the history.
            </summary>
            <param name="inputChanged"></param>
            <returns>The input string.</returns>
        </member>
        <member name="P:Microsoft.Scripting.Interpreter.CallInstruction.ArgumentCount">
            <summary>
            The number of arguments including "this" for instance methods.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.CallInstruction.Create(System.Reflection.MethodInfo)">
            <exception cref="T:System.Security.SecurityException">Instruction can't be created due to insufficient privileges.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.CallInstruction.Create(System.Reflection.MethodInfo,System.Reflection.ParameterInfo[])">
            <exception cref="T:System.Security.SecurityException">Instruction can't be created due to insufficient privileges.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.CallInstruction.TryGetParameterOrReturnType(System.Reflection.MethodInfo,System.Reflection.ParameterInfo[],System.Int32)">
            <summary>
            Gets the next type or null if no more types are available.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.CallInstruction.SlowCreate(System.Reflection.MethodInfo,System.Reflection.ParameterInfo[])">
            <summary>
            Uses reflection to create new instance of the appropriate ReflectedCaller
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.CallInstruction.FastCreate(System.Reflection.MethodInfo,System.Reflection.ParameterInfo[])">
            <summary>
            Fast creation works if we have a known primitive types for the entire
            method siganture.  If we have any non-primitive types then FastCreate
            falls back to SlowCreate which works for all types.
            
            Fast creation is fast because it avoids using reflection (MakeGenericType
            and Activator.CreateInstance) to create the types.  It does this through
            calling a series of generic methods picking up each strong type of the
            signature along the way.  When it runs out of types it news up the 
            appropriate CallInstruction with the strong-types that have been built up.
            
            One relaxation is that for return types which are non-primitive types
            we can fallback to object due to relaxed delegates.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.GotoInstruction">
            <summary>
            This instruction implements a goto expression that can jump out of any expression. 
            It pops values (arguments) from the evaluation stack that the expression tree nodes in between 
            the goto expression and the target label node pushed and not consumed yet. 
            A goto expression can jump into a node that evaluates arguments only if it carries 
            a value and jumps right after the first argument (the carried value will be used as the first argument). 
            Goto can jump into an arbitrary child of a BlockExpression since the block doesnt accumulate values 
            on evaluation stack as its child expressions are being evaluated.
            
            Goto needs to execute any finally blocks on the way to the target label.
            <example>
            { 
                f(1, 2, try { g(3, 4, try { goto L } finally { ... }, 6) } finally { ... }, 7, 8)
                L: ... 
            }
            </example>
            The goto expression here jumps to label L while having 4 items on evaluation stack (1, 2, 3 and 4). 
            The jump needs to execute both finally blocks, the first one on stack level 4 the 
            second one on stack level 2. So, it needs to jump the first finally block, pop 2 items from the stack, 
            run second finally block and pop another 2 items from the stack and set instruction pointer to label L.
            
            Goto also needs to rethrow ThreadAbortException iff it jumps out of a catch handler and 
            the current thread is in "abort requested" state.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.EnterFinallyInstruction">
            <summary>
            The first instruction of finally block.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.LeaveFinallyInstruction">
            <summary>
            The last instruction of finally block.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.LeaveExceptionHandlerInstruction">
            <summary>
            The last instruction of a catch exception handler.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.LeaveFaultInstruction">
            <summary>
            The last instruction of a fault exception handler.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.DynamicSplatInstruction">
            <summary>
            Implements dynamic call site with many arguments. Wraps the arguments into <see cref="T:Microsoft.Scripting.Runtime.ArgumentArray"/>.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.InstructionList.SetDebugCookie(System.Object)">
            <summary>
            Attaches a cookie to the last emitted instruction.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.InstructionList.CreateDynamicInstruction(System.Type,System.Runtime.CompilerServices.CallSiteBinder)">
            <exception cref="T:System.Security.SecurityException">Instruction can't be created due to insufficient privileges.</exception>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.LabelInfo">
            <summary>
            Contains compiler state corresponding to a LabelTarget
            See also LabelScopeInfo.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Interpreter.LabelScopeInfo.CanJumpInto">
            <summary>
            Returns true if we can jump into this node
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.InterpretedFrame.GroupStackFrames(System.Collections.Generic.IEnumerable{System.Diagnostics.StackFrame})">
            <summary>
            A single interpreted frame might be represented by multiple subsequent Interpreter.Run CLR frames.
            This method filters out the duplicate CLR frames.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.Interpreter">
            <summary>
            A simple forth-style stack machine for executing Expression trees
            without the need to compile to IL and then invoke the JIT.  This trades
            off much faster compilation time for a slower execution performance.
            For code that is only run a small number of times this can be a 
            sweet spot.
            
            The core loop in the interpreter is the RunInstructions method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.Interpreter.Run(Microsoft.Scripting.Interpreter.InterpretedFrame)">
            <summary>
            Runs instructions within the given frame.
            </summary>
            <remarks>
            Interpreted stack frames are linked via Parent reference so that each CLR frame of this method corresponds 
            to an interpreted stack frame in the chain. It is therefore possible to combine CLR stack traces with 
            interpreted stack traces by aligning interpreted frames to the frames of this method.
            Each group of subsequent frames of Run method corresponds to a single interpreted frame.
            </remarks>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.LightDelegateCreator">
            <summary>
            Manages creation of interpreted delegates. These delegates will get
            compiled if they are executed often enough.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Interpreter.LightDelegateCreator.SameDelegateType">
            <summary>
            true if the compiled delegate has the same type as the lambda;
            false if the type was changed for interpretation.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.LightDelegateCreator.CreateCompiledDelegate(System.Runtime.CompilerServices.StrongBox{System.Object}[])">
            <summary>
            Used by LightLambda to get the compiled delegate.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.LightDelegateCreator.Compile(System.Object)">
            <summary>
            Create a compiled delegate for the LightLambda, and saves it so
            future calls to Run will execute the compiled code instead of
            interpreting.
            </summary>
        </member>
        <member name="E:Microsoft.Scripting.Interpreter.LightLambda.Compile">
            <summary>
            Provides notification that the LightLambda has been compiled.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.LightLambdaClosureVisitor">
            <summary>
            Visits a LambdaExpression, replacing the constants with direct accesses
            to their StrongBox fields. This is very similar to what
            ExpressionQuoter does for LambdaCompiler.
            
            Also inserts debug information tracking similar to what the interpreter
            would do.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Interpreter.LightLambdaClosureVisitor._closureVars">
            <summary>
            Local variable mapping.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Interpreter.LightLambdaClosureVisitor._closureArray">
            <summary>
            The variable that holds onto the StrongBox{object}[] closure from
            the interpreter
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.Interpreter.LightLambdaClosureVisitor._shadowedVars">
            <summary>
            A stack of variables that are defined in nested scopes. We search
            this first when resolving a variable in case a nested scope shadows
            one of our variable instances.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.LightLambdaClosureVisitor.BindLambda(System.Linq.Expressions.LambdaExpression,System.Collections.Generic.Dictionary{System.Linq.Expressions.ParameterExpression,Microsoft.Scripting.Interpreter.LocalVariable})">
            <summary>
            Walks the lambda and produces a higher order function, which can be
            used to bind the lambda to a closure array from the interpreter.
            </summary>
            <param name="lambda">The lambda to bind.</param>
            <param name="closureVariables">Variables which are being accessed defined in the outer scope.</param>
            <returns>A delegate that can be called to produce a delegate bound to the passed in closure array.</returns>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.LightLambdaClosureVisitor.MergedRuntimeVariables">
            <summary>
            Provides a list of variables, supporing read/write of the values
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.LocalVariables.CopyLocals">
            <summary>
            Gets a copy of the local variables which are defined in the current scope.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Scripting.Interpreter.LocalVariables.ContainsVariable(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Checks to see if the given variable is defined within the current local scope.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Interpreter.LocalVariables.ClosureVariables">
            <summary>
            Gets the variables which are defined in an outer scope and available within the current scope.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Interpreter.LocalVariables.VariableScope">
            <summary>
            Tracks where a variable is defined and what range of instructions it's used in
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.MultiRuntimeAwareAttribute">
            <summary>
            marks a field, class, or struct as being safe to have statics which can be accessed
            from multiple runtimes.
            
            Static fields which are not read-only or marked with this attribute will be flagged 
            by a test which looks for state being shared between runtimes.  Before applying this
            attribute you should ensure that it is safe to share the state.  This is typically
            state which is lazy initialized or state which is caching values which are identical
            in all runtimes and are immutable.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.MutableTuple.SetNestedValue(System.Int32,System.Int32,System.Object)">
            <summary>
            Sets the value at the given index for a tuple of the given size.  This set supports
            walking through nested tuples to get the correct final index.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.MutableTuple.GetNestedValue(System.Int32,System.Int32)">
            <summary>
            Gets the value at the given index for a tuple of the given size.  This get
            supports walking through nested tuples to get the correct final index.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.MutableTuple.GetTupleType(System.Int32)">
            <summary>
            Gets the unbound generic Tuple type which has at lease size slots or null if a large enough tuple is not available.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.MutableTuple.MakeTupleType(System.Type[])">
            <summary>
            Creates a generic tuple with the specified types.  
            
            If the number of slots fits within the maximum tuple size then we simply 
            create a single tuple.  If it's greater then we create nested tuples 
            (e.g. a Tuple`2 which contains a Tuple`128 and a Tuple`8 if we had a size of 136).
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.MutableTuple.GetSize(System.Type)">
            <summary>
            Gets the number of usable slots in the provided Tuple type including slots available in nested tuples.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.MutableTuple.MakeTuple(System.Type,System.Object[])">
            <summary>
            Creates a new instance of tupleType with the specified args.  If the tuple is a nested
            tuple the values are added in their nested forms.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.MutableTuple.GetTupleValues(Microsoft.Scripting.MutableTuple)">
            <summary>
            Gets the values from a tuple including unpacking nested values.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.MutableTuple.GetAccessPath(System.Type,System.Int32)">
            <summary>
            Gets the series of properties that needs to be accessed to access a logical item in a potentially nested tuple.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.MutableTuple.GetAccessProperties(System.Type,System.Int32,System.Int32)">
            <summary>
            Gets the series of properties that needs to be accessed to access a logical item in a potentially nested tuple.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.MutableTuple.Create(System.Linq.Expressions.Expression[])">
            <summary>
            Provides an expression for creating a tuple with the specified values.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.PerfTrack">
            <summary>
            This class is useful for quickly collecting performance counts for expensive
            operations.  Usually this means operations involving either reflection or
            code gen.  Long-term we need to see if this can be plugged better into the
            standard performance counter architecture.
            </summary>
        </member>
        <member name="F:Microsoft.Scripting.PerfTrack.Categories.Temporary">
            <summary>
            temporary categories for quick investigation, use a custom key if you
            need to track multiple items, and if you want to keep it then create 
            a new Categories entry and rename all your temporary entries.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.ICustomScriptCodeData">
            <summary>
            Gets custom data to be serialized when saving script codes to disk.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.SavableScriptCode">
            <summary>
            ScriptCode is an instance of compiled code that is bound to a specific LanguageContext
            but not a specific ScriptScope. The code can be re-executed multiple times in different
            scopes. Hosting API counterpart for this class is <c>CompiledCode</c>.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SavableScriptCode.SaveToAssembly(System.String,Microsoft.Scripting.SavableScriptCode[])">
            <summary>
            This takes an assembly name including extension and saves the provided ScriptCode objects into the assembly.  
            
            The provided script codes can constitute code from multiple languages.  The assemblyName can be either a fully qualified 
            or a relative path.  The DLR will simply save the assembly to the desired location.  The assembly is created by the DLR and 
            if a file already exists than an exception is raised.  
            
            The DLR determines the internal format of the ScriptCode and the DLR can feel free to rev this as appropriate.  
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.SavableScriptCode.LoadFromAssembly(Microsoft.Scripting.Runtime.ScriptDomainManager,System.Reflection.Assembly)">
            <summary>
            This will take an assembly object which the user has loaded and return a new set of ScriptCodes which have 
            been loaded into the provided ScriptDomainManager.  
            
            If the language associated with the ScriptCodes has not already been loaded the DLR will load the 
            LanguageContext into the ScriptDomainManager based upon the saved LanguageContext type.  
            
            If the LanguageContext or the version of the DLR the language was compiled against is unavailable a 
            TypeLoadException will be raised unless policy has been applied by the administrator to redirect bindings.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.FileStreamContentProvider">
            <summary>
            Provides a StreamContentProvider for a stream of content backed by a file on disk.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ArrayUtils.ToArray``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Converts a generic ICollection of T into an array of T.  
            
            If the collection is already an  array of T the original collection is returned.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ArrayUtils.ToArray``2(System.Collections.Generic.ICollection{``0},System.Func{``0,``1})">
            <summary>
            Converts a generic ICollection of T into an array of R using a given conversion.  
            
            If the collection is already an array of R the original collection is returned.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.CacheDict`2">
            <summary>
            Provides a dictionary-like object used for caches which holds onto a maximum
            number of elements specified at construction time.
            
            This class is not thread safe.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.CacheDict`2.#ctor(System.Int32)">
            <summary>
            Creates a dictionary-like object used for caches.
            </summary>
            <param name="maxSize">The maximum number of elements to store.</param>
        </member>
        <member name="M:Microsoft.Scripting.Utils.CacheDict`2.TryGetValue(`0,`1@)">
            <summary>
            Tries to get the value associated with 'key', returning true if it's found and
            false if it's not present.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.CacheDict`2.Add(`0,`1)">
            <summary>
            Adds a new element to the cache, replacing and moving it to the front if the
            element is already present.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Utils.CacheDict`2.Item(`0)">
            <summary>
            Returns the value associated with the given key, or throws KeyNotFoundException
            if the key is not present.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.CheckedDictionaryEnumerator">
            <summary>
            Not all .NET enumerators throw exceptions if accessed in an invalid state. This type
            can be used to throw exceptions from enumerators implemented in IronPython.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.CollectionExtensions.ToReadOnly``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Wraps the provided enumerable into a ReadOnlyCollection{T}
            
            Copies all of the data into a new array, so the data can't be
            changed after creation. The exception is if the enumerable is
            already a ReadOnlyCollection{T}, in which case we just return it.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.EnumerableWrapper">
            <summary>
            Allows wrapping of proxy types (like COM RCWs) to expose their IEnumerable functionality
            which is supported after casting to IEnumerable, even though Reflection will not indicate 
            IEnumerable as a supported interface
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayIndex``1(System.Collections.Generic.IList{``0},System.Int32,System.String)">
            <summary>
            Requires the specified index to point inside the array.
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is outside the array.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayIndex(System.Int32,System.Int32,System.String)">
            <summary>
            Requires the specified index to point inside the array.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is outside the array.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayInsertIndex``1(System.Collections.Generic.IList{``0},System.Int32,System.String)">
            <summary>
            Requires the specified index to point inside the array or at the end
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is outside the array.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayInsertIndex(System.Int32,System.Int32,System.String)">
            <summary>
            Requires the specified index to point inside the array or at the end
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Index is outside the array.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayRange``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayRange(System.Int32,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresListRange(System.Collections.IList,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentNullException">Array is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresArrayRange(System.String,System.Int32,System.Int32,System.String,System.String)">
            <summary>
            Requires the range [offset, offset + count] to be a subset of [0, array.Count].
            </summary>
            <exception cref="T:System.ArgumentNullException">String is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Offset or count are out of range.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresNotNullItems``1(System.Collections.Generic.IList{``0},System.String)">
            <summary>
            Requires the array and all its items to be non-null.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ContractUtils.RequiresNotNullItems``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Requires the enumerable collection and all its items to be non-null.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.CopyOnWriteList`1">
            <summary>
            List optimized for few writes and multiple reads. It provides thread-safe read and write access. 
            Iteration is not thread-safe by default, but GetCopyForRead allows for iteration 
            without taking a lock.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.CopyOnWriteList`1.GetCopyForRead">
            <summary>
            Gets a copy of the contents of the list. The copy will not change even if the original
            CopyOnWriteList object is modified. This method should be used to iterate the list in
            a thread-safe way if no lock is taken. Iterating on the original list is not guaranteed 
            to be thread-safe.
            </summary>
            <returns>The returned copy should not be modified by the caller.</returns>
        </member>
        <member name="T:Microsoft.Scripting.Utils.DictionaryUnionEnumerator">
            <summary>
            Presents a flat enumerable view of multiple dictionaries
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.DynamicUtils.GetExpressions(System.Dynamic.DynamicMetaObject[])">
            <summary>
            Returns the list of expressions represented by the <see cref="T:System.Dynamic.DynamicMetaObject"/> instances.
            </summary>
            <param name="objects">An array of <see cref="T:System.Dynamic.DynamicMetaObject"/> instances to extract expressions from.</param>
            <returns>The array of expressions.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Utils.DynamicUtils.ObjectToMetaObject(System.Object,System.Linq.Expressions.Expression)">
            <summary>
            Creates an instance of <see cref="T:System.Dynamic.DynamicMetaObject"/> for a runtime value and the expression that represents it during the binding process.
            </summary>
            <param name="argValue">The runtime value to be represented by the <see cref="T:System.Dynamic.DynamicMetaObject"/>.</param>
            <param name="parameterExpression">An expression to represent this <see cref="T:System.Dynamic.DynamicMetaObject"/> during the binding process.</param>
            <returns>The new instance of <see cref="T:System.Dynamic.DynamicMetaObject"/>.</returns>
        </member>
        <member name="M:Microsoft.Scripting.Utils.DynamicUtils.LightBind``1(System.Dynamic.DynamicMetaObjectBinder,System.Object[],System.Int32)">
            <summary>
            Produces an interpreted binding using the given binder which falls over to a compiled
            binding after hitCount tries.
            
            This method should be called whenever an interpreted binding is required.  Sometimes it will
            return a compiled binding if a previous binding was produced and it's hit count was exhausted.
            In this case the binder will not be called back for a new binding - the previous one will
            be used.
            </summary>
            <typeparam name="T">The delegate type being used for the call site</typeparam>
            <param name="binder">The binder used for the call site</param>
            <param name="compilationThreshold">The number of calls before the binder should switch to a compiled mode.</param>
            <param name="args">The arguments that are passed for the binding (as received in a BindDelegate call)</param>
            <returns>A delegate which represents the interpreted binding.</returns>
        </member>
        <member name="T:Microsoft.Scripting.Utils.DynamicUtils.GenericInterpretedBinder`1.InterpretedRuleHitCheckExpression">
            <summary>
            Expression which reduces to the normal test but under the interpreter adds a count down
            check which enables compiling when the count down is reached.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.CachedBindingInfo">
            <summary>
            Base class for storing information about the binding that a specific rule is applicable for.
            
            We have a derived generic class but this class enables us to refer to it w/o having the
            generic type information around.
            
            This class tracks both the count down to when we should compile.  When we compile we
            take the Expression[T] that was used before and compile it.  While this is happening
            we continue to allow the interpreted code to run.  When the compilation is complete we
            store a thread static which tells us what binding failed and the current rule is no
            longer functional.  Finally the language binder will call us again and we'll retrieve
            and return the compiled overload.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.HybridReferenceDictionary`2">
            <summary>
            A hybrid dictionary which compares based upon object identity.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.IOUtils.SeekLine(System.IO.TextReader,System.Int32)">
            <summary>
            Seeks the first character of a specified line in the text stream.
            </summary>
            <param name="reader">The reader.</param>
            <param name="line">Line number. The current position is assumed to be line #1.</param>
            <returns>
            Returns <c>true</c> if the line is found, <b>false</b> otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.Scripting.Utils.IOUtils.ReadTo(System.IO.TextReader,System.Char)">
            <summary>
            Reads characters to a string until end position or a terminator is reached. 
            Doesn't include the terminator into the resulting string.
            Returns <c>null</c>, if the reader is at the end position.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.IOUtils.SeekTo(System.IO.TextReader,System.Char)">
            <summary>
            Reads characters until end position or a terminator is reached.
            Returns <c>true</c> if the character has been found (the reader is positioned right behind the character), 
            <c>false</c> otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.FloorDivideUnchecked(System.Int32,System.Int32)">
            <summary>
            Calculates the quotient of two 32-bit signed integers rounded towards negative infinity.
            </summary>
            <param name="x">Dividend.</param>
            <param name="y">Divisor.</param>
            <returns>The quotient of the specified numbers rounded towards negative infinity, or <code>(int)Floor((double)x/(double)y)</code>.</returns>
            <exception cref="T:System.DivideByZeroException"><paramref name="y"/> is 0.</exception>
            <remarks>The caller must check for overflow (x = Int32.MinValue, y = -1)</remarks>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.FloorDivideUnchecked(System.Int64,System.Int64)">
            <summary>
            Calculates the quotient of two 64-bit signed integers rounded towards negative infinity.
            </summary>
            <param name="x">Dividend.</param>
            <param name="y">Divisor.</param>
            <returns>The quotient of the specified numbers rounded towards negative infinity, or <code>(int)Floor((double)x/(double)y)</code>.</returns>
            <exception cref="T:System.DivideByZeroException"><paramref name="y"/> is 0.</exception>
            <remarks>The caller must check for overflow (x = Int64.MinValue, y = -1)</remarks>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.FloorRemainder(System.Int32,System.Int32)">
            <summary>
            Calculates the remainder of floor division of two 32-bit signed integers.
            </summary>
            <param name="x">Dividend.</param>
            <param name="y">Divisor.</param>
            <returns>The remainder of of floor division of the specified numbers, or <code>x - (int)Floor((double)x/(double)y) * y</code>.</returns>
            <exception cref="T:System.DivideByZeroException"><paramref name="y"/> is 0.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.FloorRemainder(System.Int64,System.Int64)">
            <summary>
            Calculates the remainder of floor division of two 32-bit signed integers.
            </summary>
            <param name="x">Dividend.</param>
            <param name="y">Divisor.</param>
            <returns>The remainder of of floor division of the specified numbers, or <code>x - (int)Floor((double)x/(double)y) * y</code>.</returns>
            <exception cref="T:System.DivideByZeroException"><paramref name="y"/> is 0.</exception>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.RoundAwayFromZero(System.Double)">
            <summary>
            Behaves like Math.Round(value, MidpointRounding.AwayFromZero)
            Needed because CoreCLR doesn't support this particular overload of Math.Round
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.RoundAwayFromZero(System.Double,System.Int32)">
            <summary>
            Behaves like Math.Round(value, precision, MidpointRounding.AwayFromZero)
            However, it works correctly on negative precisions and cases where precision is
            outside of the [-15, 15] range.
            
            (This function is also needed because CoreCLR lacks this overload.)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.EvalPolynomial(System.Double,System.Double[])">
            <summary>
            Evaluates a polynomial in v0 where the coefficients are ordered in increasing degree
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.EvalPolynomial(System.Double,System.Double[],System.Boolean)">
            <summary>
            Evaluates a polynomial in v0 where the coefficients are ordered in increasing degree
            if reverse is false, and increasing degree if reverse is true.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.SinPi(System.Double)">
            <summary>
            A numerically precise version of sin(v0 * pi)
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.AbsSinPi(System.Double)">
            <summary>
            A numerically precise version of |sin(v0 * pi)|
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.GammaRationalFunc(System.Double)">
            <summary>
            Take the quotient of the 2 polynomials forming the Lanczos approximation
            with N=13 and G=13.144565
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.PositiveGamma(System.Double)">
            <summary>
            Computes the Gamma function on positive values, using the Lanczos approximation.
            Lanczos parameters are N=13 and G=13.144565.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.MathUtils.PositiveLGamma(System.Double)">
            <summary>
            Computes the Log-Gamma function on positive values, using the Lanczos approximation.
            Lanczos parameters are N=13 and G=13.144565.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.Publisher`2">
            <summary>
            Thread safe dictionary that allows lazy-creation where readers will block for
            the creation of the lazily created value.  Call GetOrCreateValue w/ a key
            and a callback function.  If the value exists it is returned, if not the create
            callback is called (w/o any locks held).  The create call back will only be called
            once for each key.  
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.Publisher`2.PublishInfo`1">
            <summary>
            Helper class which stores the published value
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.UnwrapEnumValue(System.Object)">
            <summary>
            Converts a boxed enum value to the underlying integer value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.CreateDelegate(System.Reflection.MethodInfo,System.Type)">
            <summary>
            Creates an open delegate for the given (dynamic)method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.CreateDelegate(System.Reflection.MethodInfo,System.Type,System.Object)">
            <summary>
            Creates a closed delegate for the given (dynamic)method.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.GetObjectCallSiteDelegateType(System.Int32)">
            <summary>
            Gets a Func of CallSite, object * paramCnt, object delegate type
            that's suitable for use in a non-strongly typed call site.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.IsMandatory(System.Reflection.ParameterInfo)">
            <summary>
            Returns <c>true</c> if the specified parameter is mandatory, i.e. is not optional and doesn't have a default value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.Ancestors(System.Type)">
            <summary>
            Yields all ancestors of the given type including the type itself.
            Does not include implemented interfaces.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.GetDeclaredInterfaces(System.Type)">
            <summary>
            Like Type.GetInterfaces, but only returns the interfaces implemented by this type
            and not its parents.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.GetVisibleExtensionMethodGroups(System.Reflection.Assembly,System.Boolean)">
            <summary>
            Enumerates extension methods in given assembly. Groups the methods by declaring namespace.
            Uses a global cache if <paramref name="useCache"/> is true.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ReflectionUtils.BindGenericParameters(System.Type,System.Type,System.Func{System.Type,System.Type,System.Boolean})">
            <summary>
            Binds occurances of generic parameters in <paramref name="openType"/> against corresponding types in <paramref name="closedType"/>.
            Invokes <paramref name="binder"/>(parameter, type) for each such binding.
            Returns false if the <paramref name="openType"/> is structurally different from <paramref name="closedType"/> or if the binder returns false.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ExtensionMethodInfo.IsExtensionOf(System.Type)">
            <summary>
            Determines if a given type matches the type that the method extends. 
            The match might be non-trivial if the extended type is an open generic type with constraints.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.StringUtils.SplitWords(System.String,System.Boolean,System.Int32)">
            <summary>
            Splits text and optionally indents first lines - breaks along words, not characters.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.SynchronizedDictionary`2">
            <summary>
            Dictionary[TKey, TValue] is not thread-safe in the face of concurrent reads and writes. SynchronizedDictionary
            provides a thread-safe implementation. It holds onto a Dictionary[TKey, TValue] instead of inheriting from
            it so that users who need to do manual synchronization can access the underlying Dictionary[TKey, TValue].
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Utils.SynchronizedDictionary`2.UnderlyingDictionary">
            <summary>
            This returns the raw unsynchronized Dictionary[TKey, TValue]. Users are responsible for locking
            on it before accessing it. Also, it should not be arbitrarily handed out to other code since deadlocks
            can be caused if other code incorrectly locks on it.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.ThreadLocal`1">
            <summary>
            Provides fast strongly typed thread local storage.  This is significantly faster than
            Thread.GetData/SetData.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ThreadLocal`1.#ctor(System.Boolean)">
            <summary>
            True if the caller will guarantee that all cleanup happens as the thread
            unwinds.
            
            This is typically used in a case where the thread local is surrounded by
            a try/finally block.  The try block pushes some state, the finally block
            restores the previous state.  Therefore when the thread exits the thread
            local is back to it's original state.  This allows the ThreadLocal object
            to not check the current owning thread on retrieval.
            </summary>
        </member>
        <member name="P:Microsoft.Scripting.Utils.ThreadLocal`1.Value">
            <summary>
            Gets or sets the value for the current thread.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ThreadLocal`1.GetOrCreate(System.Func{`0})">
            <summary>
            Gets the current value if its not == null or calls the provided function
            to create a new value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ThreadLocal`1.Update(System.Func{`0,`0})">
            <summary>
            Calls the provided update function with the current value and
            replaces the current value with the result of the function.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ThreadLocal`1.Update(`0)">
            <summary>
            Replaces the current value with a new one and returns the old value.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ThreadLocal`1.GetStorageInfo">
            <summary>
            Gets the StorageInfo for the current thread.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ThreadLocal`1.RetryOrCreateStorageInfo(Microsoft.Scripting.Utils.ThreadLocal{`0}.StorageInfo[])">
            <summary>
            Called when the fast path storage lookup fails. if we encountered the Empty storage 
            during the initial fast check then spin until we hit non-empty storage and try the fast 
            path again.
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.ThreadLocal`1.CreateStorageInfo">
            <summary>
            Creates the StorageInfo for the thread when one isn't already present.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.ThreadLocal`1.StorageInfo">
            <summary>
            Helper class for storing the value.  We need to track if a ManagedThreadId
            has been re-used so we also store the thread which owns the value.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.TypeMemberCache`1">
            <summary>
            Caches type member lookup.
            </summary>
            <remarks>
            When enumerating members (methods, properties, events) of a type (declared or inherited) Reflection enumerates all
            runtime members of the type and its base types and caches the result.
            When looking for a member of a specific name Reflection still enumerates all and filters out those that don't match the name.
            That's inefficient when looking for members of multiple names one by one.
            Instead we build a map of name to member list and then answer subsequent queries by simply looking up the dictionary.
            </remarks>
        </member>
        <member name="M:Microsoft.Scripting.Utils.TypeUtils.GetNumericConversionOrder(System.TypeCode,System.Int32@,System.Int32@)">
            <summary>
            Returns a numerical code of the size of a type.  All types get both a horizontal
            and vertical code.  Types that are lower in both dimensions have implicit conversions
            to types that are higher in both dimensions.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.ValueArray`1">
            <summary>
            Represents an array that has value equality.
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.WeakCollection`1">
            <summary>
            Simple class for tracking a list of items and enumerating over them.
            The items are stored in weak references; if the objects are collected,
            they will not be seen when enumerating.
            </summary>
            <typeparam name="T">The type of the collection element.</typeparam>
        </member>
        <member name="T:Microsoft.Scripting.Utils.WeakDictionary`2">
            <summary>
            Similar to Dictionary[TKey,TValue], but it also ensures that the keys will not be kept alive
            if the only reference is from this collection. The value will be kept alive as long as the key
            is alive.
            
            This currently has a limitation that the caller is responsible for ensuring that an object used as 
            a key is not also used as a value in *any* instance of a WeakHash. Otherwise, it will result in the
            object being kept alive forever. This effectively means that the owner of the WeakHash should be the
            only one who has access to the object used as a value.
            
            Currently, there is also no guarantee of how long the values will be kept alive even after the keys
            get collected. This could be fixed by triggerring CheckCleanup() to be called on every garbage-collection
            by having a dummy watch-dog object with a finalizer which calls CheckCleanup().
            </summary>
        </member>
        <member name="M:Microsoft.Scripting.Utils.WeakDictionary`2.CheckCleanup">
            <summary>
            Check if any of the keys have gotten collected
            
            Currently, there is also no guarantee of how long the values will be kept alive even after the keys
            get collected. This could be fixed by triggerring CheckCleanup() to be called on every garbage-collection
            by having a dummy watch-dog object with a finalizer which calls CheckCleanup().
            </summary>
        </member>
        <member name="T:Microsoft.Scripting.Utils.WeakHandle">
            <summary>
            Changes the semantics of GC handle to return <c>null</c> instead of throwing
            an <see cref="T:System.InvalidOperationException"/>.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.Adler32">
            <summary>
            This class represents adler32 checksum algorithm.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Adler32.GetAdler32Checksum(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            This static method returns adler32 checksum of the buffer data
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.Deflate">
            <summary>
            Implementation of the Deflate compression algorithm.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.Deflate.Config">
            <summary>
            Deflate algorithm configuration parameters class
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.Config.good_length">
            <summary>
            reduce lazy search above this match length
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.Config.max_lazy">
            <summary>
            do not perform lazy search above this match length
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.Config.nice_length">
            <summary>
            quit search above this match length
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.Config.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor which initializes class inner fields
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.MAX_MEM_LEVEL">
            <summary>
            Maximum memory level
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.Z_DEFAULT_COMPRESSION">
            <summary>
            Defalult compression method
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.DEF_MEM_LEVEL">
            <summary>
            Default memory level
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.config_table">
            <summary>
            Deflate class congiration table
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.NeedMore">
            <summary>
            block not completed, need more input or more output
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.BlockDone">
            <summary>
            Block internalFlush performed
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.FinishStarted">
            <summary>
            Finish started, need only more output at next deflate
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.FinishDone">
            <summary>
            finish done, accept no more input or output
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.PRESET_DICT">
            <summary>
            preset dictionary flag in zlib header
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.Z_DEFLATED">
            <summary>
            The deflate compression method
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.Buf_size">
            <summary>
            The size of the buffer
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.REP_3_6">
            <summary>
            repeat previous bit length 3-6 times (2 bits of repeat count)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.REPZ_3_10">
            <summary>
            repeat a zero length 3-10 times  (3 bits of repeat count)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.REPZ_11_138">
            <summary>
            repeat a zero length 11-138 times  (7 bits of repeat count)
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Deflate.level">
            <summary>
            Gets or sets the Compression level.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Deflate.Pending">
            <summary>
            Gets or sets the Number of bytes in the pending buffer.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Deflate.Pending_buf">
            <summary>
            Gets or sets the Output pending buffer.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Deflate.Pending_out">
            <summary>
            Gets or sets the next pending byte to output to the stream.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Deflate.NoHeader">
            <summary>
            Gets or sets a value indicating whether to suppress zlib header and adler32.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.strm">
            <summary>
            Pointer back to this zlib stream
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.status">
            <summary>
            As the name implies
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.pending_buf_size">
            <summary>
            Size of Pending_buf
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.data_type">
            <summary>
            UNKNOWN, BINARY or ASCII
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.method">
            <summary>
            STORED (for zip only) or DEFLATED
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.last_flush">
            <summary>
            Value of internalFlush parameter for previous deflate call
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.w_size">
            <summary>
            LZ77 Window size (32K by default)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.w_bits">
            <summary>
            log2(w_size)  (8..16)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.w_mask">
            <summary>
            w_size - 1
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.window">
            <summary>
            Sliding Window. Input bytes are ReadPos into the second half of the Window,
            and move to the first half later to keep a dictionary of at least wSize
            bytes. With this organization, matches are limited to a distance of
            wSize-MAX_MATCH bytes, but this ensures that IO is always
            performed with a length multiple of the block size. Also, it limits
            the Window size to 64K, which is quite useful on MSDOS.
            To do: use the user input buffer as sliding Window.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.window_size">
            <summary>
            Actual size of Window: 2*wSize, except when the user input buffer is directly used as sliding Window.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.prev">
            <summary>
            Link to older string with same hash index. To limit the size of this
            array to 64K, this link is maintained only for the last 32K strings.
            An index in this array is thus a Window index modulo 32K.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.head">
            <summary>
            Heads of the hash chains or NIL.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.ins_h">
            <summary>
            hash index of string to be inserted
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.hash_size">
            <summary>
            number of elements in hash table
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.hash_bits">
            <summary>
            log2(hash_size)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.hash_mask">
            <summary>
            hash_size-1
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.hash_shift">
            <summary>
            Number of bits by which ins_h must be shifted at each input
            step. It must be such that after MIN_MATCH steps, the oldest
            byte no longer takes part in the hash key, that is:
            hash_shift * MIN_MATCH >= hash_bits
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.block_start">
            <summary>
            Window position at the beginning of the current output block. Gets negative when the Window is moved backwards.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.match_length">
            <summary>
            length of best match
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.prev_match">
            <summary>
            previous match
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.match_available">
            <summary>
            set if previous match exists
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.strstart">
            <summary>
            start of string to insert
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.match_start">
            <summary>
            start of matching string
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.lookahead">
            <summary>
            number of valid bytes ahead in Window
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.prev_length">
            <summary>
            Length of the best match at previous step. Matches not greater than this
            are discarded. This is used in the lazy match evaluation.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.max_chain_length">
            <summary>
            To speed up deflation, hash chains are never searched beyond this
            length.  A higher limit improves compression ratio but degrades the speed.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.max_lazy_match">
            <summary>
            Attempt to find a better match only when the current match is strictly
            smaller than this value. This mechanism is used only for compression
            levels >= 4.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.strategy">
            <summary>
            favor or force Huffman coding
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.good_match">
            <summary>
            Use a faster search when the previous match is longer than this
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.nice_match">
            <summary>
            Stop searching when current match exceeds this
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.dyn_ltree">
            <summary>
            literal and length tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.dyn_dtree">
            <summary>
            distance tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.bl_tree">
            <summary>
             Huffman tree for bit lengths
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.l_desc">
            <summary>
            Desc for literal tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.d_desc">
            <summary>
            desc for distance tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.bl_desc">
            <summary>
            desc for bit length tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.bl_count">
            <summary>
            number of codes at each bit length for an optimal tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.heap">
            <summary>
            heap used to build the Huffman trees
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.heap_len">
            <summary>
            number of elements in the heap
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.heap_max">
            <summary>
            element of largest frequency
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.depth">
            <summary>
            Depth of each subtree used as tie breaker for trees of equal frequency
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.l_buf">
            <summary>
            index for literals or lengths
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.lit_bufsize">
            <summary>
             Size of match buffer for literals/lengths.  There are 4 reasons for
             limiting lit_bufsize to 64K:
               - frequencies can be kept in 16 bit counters
               - if compression is not successful for the first block, all input
                 data is still in the Window so we can still emit a stored block even
                 when input comes from standard input.  (This can also be done for
                 all blocks if lit_bufsize is not greater than 32K.)
               - if compression is not successful for a file smaller than 64K, we can
                 even emit a stored file instead of a stored block (saving 5 bytes).
                 This is applicable only for zip (not gzip or zlib).
               - creating new Huffman trees less frequently may not provide fast
                 adaptation to changes in the input data statistics. (Take for
                 example a binary file with poorly compressible code followed by
                 a highly compressible string table.) Smaller buffer sizes give
                 fast adaptation but have of course the overhead of transmitting
                 trees more frequently.
               - I can't count above 4
            </summary> 
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.last_lit">
            <summary>
            running index in l_buf
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.d_buf">
            <summary>
            index of pendig_buf
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.opt_len">
            <summary>
            bit length of current block with optimal trees
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.static_len">
            <summary>
            bit length of current block with static trees
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.matches">
            <summary>
            number of string matches in current block
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.last_eob_len">
            <summary>
            bit length of EOB code for last block
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.bi_buf">
            <summary>
            Output buffer. bits are inserted starting at the bottom (least
            significant bits).
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Deflate.bi_valid">
            <summary>
            Number of valid bits in bi_buf.  All bits above the last valid bit
            are always zero.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.lm_init">
            <summary>
            Initialization
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.tr_init">
            <summary>
            Initialize the tree data structures for a new zlib stream.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.init_block">
            <summary>
            Initializes block
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.pqdownheap(System.Int16[],System.Int32)">
            <summary>
             Restore the heap property by moving down the tree starting at node k,
             exchanging a node with the smallest of its two sons if necessary, stopping
             when the heap property is re-established (each father smaller than its
             two sons).
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.scan_tree(System.Int16[],System.Int32)">
            <summary>
             Scan a literal or distance tree to determine the frequencies of the codes
             in the bit length tree.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.build_bl_tree">
            <summary>
             Construct the Huffman tree for the bit lengths and return the index in
             bl_order of the last bit length code to send.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.send_all_trees(System.Int32,System.Int32,System.Int32)">
            <summary>
             Send the header for a block using dynamic Huffman trees: the counts, the
             lengths of the bit length codes, the literal tree and the distance tree.
             IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.send_tree(System.Int16[],System.Int32)">
            <summary>
             Send a literal or distance tree in compressed form, using the codes in
             bl_tree.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.put_byte(System.Byte[],System.Int32,System.Int32)">
            <summary>
             Output a byte on the stream.
             IN assertion: there is enough room in Pending_buf.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.put_byte(System.Byte)">
            <summary>
            Adds a byte to the buffer
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate._tr_align">
            <summary>
             Send one empty static block to give enough lookahead for inflate.
             This takes 10 bits, of which 7 may remain in the bit buffer.
             The current inflate code requires 9 bits of lookahead. If the
             last two codes for the previous block (real code plus EOB) were coded
             on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
             the last real code. In this case we send two empty static blocks instead
             of one. (There are no problems if the previous block is stored or fixed.)
             To simplify the code, we assume the worst case of last real code encoded
             on one bit only.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate._tr_tally(System.Int32,System.Int32)">
            <summary>
            Save the match info and tally the frequency counts. Return true if
            the current block must be flushed.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.compress_block(System.Int16[],System.Int16[])">
            <summary>
             Send the block data compressed using the given Huffman trees
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.set_data_type">
            <summary>
            Set the data type to ASCII or BINARY, using a crude approximation:
            binary if more than 20% of the bytes are &lt;= 6 or &gt;= 128, ascii otherwise.
            IN assertion: the fields freq of dyn_ltree are set and the total of all
            frequencies does not exceed 64K (to fit in an int on 16 bit machines).
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.bi_flush">
            <summary>
            Flush the bit buffer, keeping at most 7 bits in it.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.bi_windup">
            <summary>
            Flush the bit buffer and align the output on a byte boundary
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.copy_block(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Copy a stored block, storing first the length and its
            one's complement if requested.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.flush_block_only(System.Boolean)">
            <summary>
            Flushes block
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflate_stored(System.Int32)">
            <summary>
            Copy without compression as much as possible from the input stream, return
            the current block state.
            This function does not insert new strings in the dictionary since
            uncompressible data is probably not useful. This function is used
            only for the level=0 compression option.
            NOTE: this function should be optimized to avoid extra copying from
            Window to Pending_buf.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate._tr_stored_block(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Send a stored block
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate._tr_flush_block(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Determine the best encoding for the current block: dynamic trees, static
            trees or store, and output the encoded block to the zip file.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.fill_window">
            <summary>
             Fill the Window when the lookahead becomes insufficient.
             Updates strstart and lookahead.
            
             IN assertion: lookahead less than MIN_LOOKAHEAD
             OUT assertions: strstart less than or equal to window_size-MIN_LOOKAHEAD
                At least one byte has been ReadPos, or _avail_in == 0; reads are
                performed for at least two bytes (required for the zip translate_eol
                option -- not supported here).
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflate_fast(System.Int32)">
            <summary>
             Compress as much as possible from the input stream, return the current
             block state.
             This function does not perform lazy evaluation of matches and inserts
             new strings in the dictionary only for unmatched strings or for short
             matches. It is used only for the fast compression options.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflate_slow(System.Int32)">
            <summary>
             Same as above, but achieves better compression. We use a lazy
             evaluation for matches: a match is finally adopted only if there is
             no better match at the next Window position.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.longest_match(System.Int32)">
            <summary>
            Finds the longest matching data part
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.DeflateInit(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32,System.Int32)">
            <summary>
            Deflate algorithm initialization
            </summary>
            <param name="strm">ZStream object</param>
            <param name="level">Compression level</param>
            <param name="bits">Window bits</param>
            <returns>A result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.DeflateInit(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32)">
            <summary>
            Initializes deflate algorithm
            </summary>
            <param name="strm">ZStream object</param>
            <param name="level">Compression level</param>
            <returns>Operation result result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.DeflateInit2(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32,System.Int32,System.Int32,ComponentAce.Compression.Libs.ZLib.CompressionStrategy)">
            <summary>
            Deflate algorithm initialization
            </summary>
            <param name="strm">ZStream object</param>
            <param name="level">Compression level</param>
            <param name="windowBits">Window bits</param>
            <param name="memLevel">Memory level</param>
            <param name="strategy">Compression strategy</param>
            <returns>Operation result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflateReset(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Resets the current state of deflate object
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflateEnd">
            <summary>
            Finish compression with deflate algorithm
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflateParams(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32,ComponentAce.Compression.Libs.ZLib.CompressionStrategy)">
            <summary>
            Sets deflate algorithm parameters
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflateSetDictionary(ComponentAce.Compression.Libs.ZLib.ZStream,System.Byte[],System.Int32)">
            <summary>
            Sets deflate dictionary
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.deflate(ComponentAce.Compression.Libs.ZLib.ZStream,ComponentAce.Compression.Libs.ZLib.FlushStrategy)">
            <summary>
            Performs data compression with the deflate algorithm
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Deflate.#cctor">
            <summary>
            Static constructor initializes config_table
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.mode">
            <summary>
            current inflate_block mode 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.left">
            <summary>
            if STORED, bytes left to copy 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.table">
            <summary>
            table lengths (14 bits) 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.index">
            <summary>
            index into blens (or border) 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.blens">
            <summary>
            bit lengths of codes 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.bb">
            <summary>
            bit length tree depth 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.tb">
            <summary>
            bit length decoding tree 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.codes">
            <summary>
            if CODES, current state 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.last">
            <summary>
            true if this block is the last block 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.hufts">
            <summary>
            single malloc for tree space 
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.needCheck">
            <summary>
            need check
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfBlocks.check">
            <summary>
            check on output 
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.InfBlocks.Window">
            <summary>
            Gets or sets the sliding window.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.InfBlocks.End">
            <summary>
            Gets or sets the one byte after sliding Window.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.InfBlocks.ReadPos">
            <summary>
            Gets or sets the Window ReadPos pointer.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.InfBlocks.WritePos">
            <summary>
            Gets or sets the Window WritePos pointer.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.InfBlocks.BitK">
            <summary>
            Gets or sets the bits in bit buffer. 
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.InfBlocks.BitB">
            <summary>
            Gets or sets the bit buffer.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfBlocks.reset(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int64[])">
            <summary>
            Resets this InfBlocks class instance
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfBlocks.proc(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32)">
            <summary>
            Block processing functions
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfBlocks.free(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Frees inner buffers
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfBlocks.set_dictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets dictionary
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfBlocks.sync_point">
            <summary>
             Returns true if inflate is currently at the End of a block generated
             by Z_SYNC_FLUSH or Z_FULL_FLUSH. 
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfBlocks.inflate_flush(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32)">
            <summary>
            copy as much as possible from the sliding Window to the output area
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.InflateCodesMode">
            <summary>
            Inflate codes mode
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.InfCodes">
            <summary>
            This class is used by the InfBlocks class
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.mode">
            <summary>
            current inflate_codes mode
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.count">
            <summary>
            length
            </summary>        
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.tree">
            <summary>
            pointer into tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.tree_index">
            <summary>
            current index of the tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.need">
            <summary>
            
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.lbits">
            <summary>
            ltree bits decoded per branch
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.dbits">
            <summary>
            dtree bits decoded per branch
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.ltree">
            <summary>
            literal/length/eob tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.ltree_index">
            <summary>
            literal/length/eob tree index
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.dtree">
            <summary>
            distance tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InfCodes.dtree_index">
            <summary>
            distance tree index
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfCodes.#ctor(System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32[],System.Int32,ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Constructor which takes literal, distance trees, corresponding bites decoded for branches, corresponding indexes and a ZStream object 
            </summary>        
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfCodes.#ctor(System.Int32,System.Int32,System.Int32[],System.Int32[],ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Constructor which takes literal, distance trees, corresponding bites decoded for branches and a ZStream object 
            </summary>   
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfCodes.proc(ComponentAce.Compression.Libs.ZLib.InfBlocks,ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32)">
            <summary>
            Block processing method
            </summary>
            <param name="s">An instance of the InfBlocks class</param>
            <param name="z">A ZStream object</param>
            <param name="r">A result code</param>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfCodes.free(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Frees allocated resources
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfCodes.inflate_fast(System.Int32,System.Int32,System.Int32[],System.Int32,System.Int32[],System.Int32,ComponentAce.Compression.Libs.ZLib.InfBlocks,ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Fast inflate procedure. Called with number of bytes left to WritePos in Window at least 258
            (the maximum string length) and number of input bytes available
            at least ten.  The ten bytes are six bytes for the longest length/
            distance pair plus four bytes for overloading the bit buffer.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.InflateMode">
            <summary>
            This enumeration contains modes of inflate processing
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.METHOD">
            <summary>
            waiting for method byte
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.FLAG">
            <summary>
            waiting for flag byte
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.DICT4">
            <summary>
            four dictionary check bytes to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.DICT3">
            <summary>
            three dictionary check bytes to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.DICT2">
            <summary>
            two dictionary check bytes to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.DICT1">
            <summary>
            one dictionary check byte to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.DICT0">
            <summary>
            waiting for inflateSetDictionary
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.BLOCKS">
            <summary>
            decompressing blocks
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.CHECK4">
            <summary>
            four check bytes to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.CHECK3">
            <summary>
            three check bytes to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.CHECK2">
            <summary>
            two check bytes to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.CHECK1">
            <summary>
            one check byte to go
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.DONE">
            <summary>
            finished check, done
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.InflateMode.BAD">
            <summary>
            got an error--stay here
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.mode">
            <summary>
            current inflate mode
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.method">
            <summary>
            if FLAGS, method byte
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.was">
            <summary>
            computed check value
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.need">
            <summary>
            stream check value
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.marker">
            <summary>
            if BAD, inflateSync's marker bytes count
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.nowrap">
            <summary>
            flag for no wrapper
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.wbits">
            <summary>
            log2(Window size)  (8..15, defaults to 15)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Inflate.blocks">
            <summary>
            current inflate_blocks state
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflateReset(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Resets the Inflate algorithm
            </summary>
            <param name="z">A ZStream object</param>
            <returns>A result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflateEnd(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Finishes the inflate algorithm processing
            </summary>
            <param name="z">A ZStream object</param>
            <returns>Operation result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflateInit(ComponentAce.Compression.Libs.ZLib.ZStream,System.Int32)">
            <summary>
            Initializes the inflate algorithm
            </summary>
            <param name="z">A ZStream object</param>
            <param name="windowBits">Window size</param>
            <returns>Operation result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflate(ComponentAce.Compression.Libs.ZLib.ZStream,ComponentAce.Compression.Libs.ZLib.FlushStrategy)">
            <summary>
            Runs inflate algorithm
            </summary>
            <param name="z">A ZStream object</param>
            <param name="flush">Flush strategy</param>
            <returns>Operation result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflateSetDictionary(ComponentAce.Compression.Libs.ZLib.ZStream,System.Byte[],System.Int32)">
            <summary>
            Sets dictionary for the inflate operation
            </summary>
            <param name="z">A ZStream object</param>
            <param name="dictionary">An array of byte - dictionary</param>
            <param name="dictLength">Dictionary length</param>
            <returns>Operation result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflateSync(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Inflate synchronization
            </summary>
            <param name="z">A ZStream object</param>
            <returns>Operation result code</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Inflate.inflateSyncPoint(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
             Returns true if inflate is currently at the End of a block generated
             by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
             implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH
             but removes the length bytes of the resulting empty stored block. When
             decompressing, PPP checks that at the End of input packet, inflate is
             waiting for these length bytes.
             </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.GzipHeader.CreateRemover(ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Creates header remover.
            As long as header is not completed, call to Remover.MoveNext() returns true and
            adjust state of z.
            </summary>
            <param name="z">Stream where gzip header will appear.</param>
            <returns></returns>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.InfTreeUtil">
            <summary>
            Contains utility information for the InfTree class
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfTree.huft_build(System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[])">
            <summary>
            Given a list of code lengths and a maximum table size, make a set of
            tables to decode that set of codes.  
            </summary>
            <returns>Return (int)ZLibResultCode.Z_OK on success, (int)ZLibResultCode.Z_DATA_ERROR if the given code set is incomplete (the tables are still built in this case), (int)ZLibResultCode.Z_DATA_ERROR if the input is invalid (an over-subscribed set of lengths), or (int)ZLibResultCode.Z_DATA_ERROR if not enough memory.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfTree.inflate_trees_bits(System.Int32[],System.Int32[],System.Int32[],System.Int32[],ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Build trees
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfTree.inflate_trees_dynamic(System.Int32,System.Int32,System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Builds dynamic trees
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.InfTree.inflate_trees_fixed(System.Int32[],System.Int32[],System.Int32[][],System.Int32[][],ComponentAce.Compression.Libs.ZLib.ZStream)">
            <summary>
            Build fixed trees
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.StaticTree.MAX_BL_BITS">
            <summary>
             Bit length codes must not exceed MAX_BL_BITS bits
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.Tree">
            <summary>
            This class represents a tree and is used in the Deflate class
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Tree.dyn_tree">
            <summary>
            The dynamic tree
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Tree.max_code">
            <summary>
            Largest code with non zero frequency
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.Tree.stat_desc">
            <summary>
            the corresponding static tree
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Tree.DynTree">
            <summary>
            The dynamic tree
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Tree.MaxCode">
            <summary>
            Largest code with non zero frequency
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.Tree.StatDesc">
            <summary>
            the corresponding static tree
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Tree.d_code(System.Int32)">
            <summary>
            Mapping from a distance to a distance code. dist is the distance - 1 and
            must not have side effects. _dist_code[256] and _dist_code[257] are never
            used.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Tree.gen_bitlen(ComponentAce.Compression.Libs.ZLib.Deflate)">
            <summary>
             Compute the optimal bit lengths for a tree and update the total bit length
             for the current block.
             IN assertion: the fields freq and dad are set, heap[heap_max] and
                above are the tree nodes sorted by increasing frequency.
             OUT assertions: the field count is set to the optimal bit length, the
                 array bl_count contains the frequencies for each bit length.
                 The length opt_len is updated; static_len is also updated if stree is
                 not null.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Tree.build_tree(ComponentAce.Compression.Libs.ZLib.Deflate)">
            <summary>
             Construct one Huffman tree and assigns the code bit strings and lengths.
             Update the total bit length for the current block.
             IN assertion: the field freq is set for all tree elements.
             OUT assertions: the fields count and code are set to the optimal bit length
                 and corresponding code. The length opt_len is updated; static_len is
                 also updated if stree is not null. The field max_code is set.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Tree.gen_codes(System.Int16[],System.Int32,System.Int16[])">
            <summary>
             Generate the codes for a given tree and bit counts (which need not be
             optimal).
             IN assertion: the array bl_count contains the bit length statistics for
             the given tree and the field count is set for all tree elements.
             OUT assertion: the field code is set for all tree elements of non
                 zero code length.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.Tree.bi_reverse(System.Int32,System.Int32)">
            <summary>
             Reverse the first count bits of a code, using straightforward code (a faster
             method would use a table)
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.ZLibCompressionLevel">
            <summary>
            Some constants for specifying compression levels. Methods which takes a compression level as a parameter expects an integer value from 0 to 9. You can either specify an integer value or use constants for some most widely used compression levels.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibCompressionLevel.Z_NO_COMPRESSION">
            <summary>
             No compression should be used at all.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibCompressionLevel.Z_BEST_SPEED">
            <summary>
            Minimal compression, but greatest speed.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibCompressionLevel.Z_BEST_COMPRESSION">
            <summary>
            Maximum compression, but slowest.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibCompressionLevel.Z_DEFAULT_COMPRESSION">
            <summary>
            Select default compression level (good compression, good speed).
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.CompressionStrategy">
            <summary>
            Compression strategies. The strategy parameter is used to tune the compression algorithm. The strategy parameter only affects the compression ratio but not the correctness of the compressed output even if it is not set appropriately.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.CompressionStrategy.Z_FILTERED">
            <summary>
            This strategy is designed for filtered data. Data which consists of mostly small values, with random distribution should use Z_FILTERED. With this strategy, less string matching is performed.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.CompressionStrategy.Z_HUFFMAN_ONLY">
            <summary>
            Z_HUFFMAN_ONLY forces Huffman encoding only (no string match)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.CompressionStrategy.Z_DEFAULT_STRATEGY">
            <summary>
            The default strategy is the most commonly used. With this strategy, string matching and huffman compression are balanced.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.FlushStrategy">
            <summary>
            Flush strategies
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_NO_FLUSH">
            <summary>
              Do not internalFlush data, but just write data as normal to the output buffer. This is the normal way in which data is written to the output buffer.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_PARTIAL_FLUSH">
            <summary>
            Obsolete. You should use Z_SYNC_FLUSH instead.
            </summary>        
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_SYNC_FLUSH">
            <summary>
            All pending output is flushed to the output buffer and the output is aligned on a byte boundary, so that the decompressor can get all input data available so far.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FULL_FLUSH">
            <summary>
            All output is flushed as with Z_SYNC_FLUSH, and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if random access is desired. Using Z_FULL_FLUSH too often can seriously degrade the compression. ZLib_InflateSync will locate points in the compression string where a full has been performed.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH">
            <summary>
            Notifies the module that the input has now been exhausted. Pending input is processed, pending output is flushed and calls return with Z_STREAM_END if there was enough output space.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.ZLibResultCode">
            <summary>
            Results of operations in ZLib library
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK">
            <summary>
             No failure was encountered, the operation completed without problem.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END">
            <summary>
            No failure was encountered, and the input has been exhausted.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_NEED_DICT">
            <summary>
            A preset dictionary is required for decompression of the data.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_ERRNO">
            <summary>
            An internal error occurred
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR">
            <summary>
            The stream structure was inconsistent
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR">
            <summary>
            Input data has been corrupted (for decompression).
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_MEM_ERROR">
            <summary>
            Memory allocation failed.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_BUF_ERROR">
            <summary>
            There was not enough space in the output buffer.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_VERSION_ERROR">
            <summary>
            The version supplied does not match that supported by the ZLib module.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.DeflateState">
            <summary>
            States of deflate operation
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.BlockType">
            <summary>
            Data block types, i.e. binary or ascii text
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.ZLibUtil">
            <summary>
            Helper class
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.CopyLargeArrayToSmall.CopyData">
            <summary>
            Copies large array which was passed as srcBuf to the Initialize method into the destination array which were passes as destBuff
            </summary>
            <returns>The number of bytes copied</returns>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibUtil.MAX_WBITS">
            <summary>
            Max Window size
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibUtil.PRESET_DICT">
            <summary>
            preset dictionary flag in zlib header
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibUtil.zLibBufSize">
            <summary>
            The size of the buffer
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibUtil.Z_DEFLATED">
            <summary>
            Deflate compression method index
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.Identity(System.Int64)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.Identity(System.UInt64)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.Identity(System.Single)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.Identity(System.Double)">
            <summary>
            This method returns the literal value received
            </summary>
            <param name="literal">The literal to return</param>
            <returns>The received value</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.URShift(System.Int32,System.Int64)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.URShift(System.Int64,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.URShift(System.Int64,System.Int64)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.ReadInput(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>Reads a number of characters from the current source Stream and writes the data to the target array at the specified index.</summary>
            <param name="sourceStream">The source Stream to ReadPos from.</param>
            <param name="target">Contains the array of characters ReadPos from the source Stream.</param>
            <param name="start">The starting index of the target array.</param>
            <param name="count">The maximum number of characters to ReadPos from the source Stream.</param>
            <returns>The number of characters ReadPos. The number will be less than or equal to count depending on the data available in the source Stream. Returns -1 if the End of the stream is reached.</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.ReadInput(System.IO.TextReader,System.Byte[],System.Int32,System.Int32)">
            <summary>Reads a number of characters from the current source TextReader and writes the data to the target array at the specified index.</summary>
            <param name="sourceTextReader">The source TextReader to ReadPos from</param>
            <param name="target">Contains the array of characteres ReadPos from the source TextReader.</param>
            <param name="start">The starting index of the target array.</param>
            <param name="count">The maximum number of characters to ReadPos from the source TextReader.</param>
            <returns>The number of characters ReadPos. The number will be less than or equal to count depending on the data available in the source TextReader. Returns -1 if the End of the stream is reached.</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.ToByteArray(System.String)">
            <summary>
            Converts a string to an array of bytes
            </summary>
            <param name="sourceString">The string to be converted</param>
            <returns>The new array of bytes</returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZLibUtil.ToCharArray(System.Byte[])">
            <summary>
            Converts an array of bytes to an array of chars
            </summary>
            <param name="byteArray">The array of bytes to convert</param>
            <returns>The new array of chars</returns>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZLibUtil.DIST_CODE_LEN">
            <summary>
            see definition of array dist_code below
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.ZStream">
            <summary>
            ZStream is used to store user data to compress/decompress.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream.MAX_MEM_LEVEL">
            <summary>
            Maximum memory level
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._next_in">
            <summary>
            Next input byte array
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._next_in_index">
            <summary>
            Index of the first byte in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in">input array</see>.
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._avail_in">
            <summary>
            Number of bytes available at _next_in
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._total_in">
            <summary>
            total nb of input bytes ReadPos so far
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._next_out">
            <summary>
            Byte array for the next output block
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._next_out_index">
            <summary>
            Index of the first byte in the _next_out array
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._avail_out">
            <summary>
            Remaining free space at _next_out
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._total_out">
            <summary>
            Total number of bytes in output array
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._msg">
            <summary>
            A string to store operation result message (corresponding to result codes)
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._dstate">
            <summary>
            A deflate object to perform data compression
            </summary>
        </member>
        <member name="F:ComponentAce.Compression.Libs.ZLib.ZStream._istate">
            <summary>
            Inflate object to perform data decompression
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.adler">
            <summary>
            Adler-32 value for uncompressed data processed so far.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.Data_type">
            <summary>
            Best guess about the data type: ascii or binary
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in">
            <summary>
            Gets/Sets the next input byte array.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in_index">
            <summary>
            Index of the first byte in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in">input array</see>.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in">
            <summary>
            Gets/Sets the number of bytes available in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in">input buffer</see>.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.total_in">
            <summary>
            Gets/Sets the total number of bytes in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in">input buffer</see>.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out">
            <summary>
            Gets/Sets the buffer for the next output data.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out_index">
            <summary>
            Gets/Sets the index of the first byte in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out" /> byte array to write to.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out">
            <summary>
            Gets/Sets the remaining free space in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out" /> buffer.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.total_out">
            <summary>
            Gets/Sets the total number of bytes in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out">output array</see>.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.msg">
            <summary>
            Gets sets the last error message occurred during class operations.
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.dstate">
            <summary>
            A deflate object to perform data compression
            </summary>
        </member>
        <member name="P:ComponentAce.Compression.Libs.ZLib.ZStream.istate">
            <summary>
            Inflate object to perform data decompression
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit">
            <summary>
            Initializes the internal stream state for decompression. The fields <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in" />, <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in" /> must be 
            initialized before by the caller. If <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in" /> is not <c>null</c> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in" /> is large 
            enough (the exact value depends on the compression method), <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit" /> determines the compression 
            method from the ZLib header and allocates all data structures accordingly; otherwise the allocation will be deferred 
            to the first call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" />. 
            </summary>
            <returns>
            inflateInit returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK" /> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_MEM_ERROR" /> if there was not enough memory,  
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_VERSION_ERROR" /> if the ZLib library version is incompatible with the version assumed by the caller. 
            <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.msg" /> is set to <c>null</c> if there is no error message. <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit" /> does not perform any decompression 
            apart from reading the ZLib header if present: this will be done by <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" />. (So <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in" /> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in" /> 
            may be modified, but <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out" /> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out" /> are unchanged.)
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit(System.Int32)">
            <summary>
            This is another version of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit" /> with an extra parameter. The fields <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in" />, <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in" /> must be 
            initialized before by the caller. If <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in" /> is not <c>null</c> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in" /> is large enough 
            (the exact value depends on the compression method), <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit(System.Int32)" /> determines the compression method from 
            the ZLib header and allocates all data structures accordingly; otherwise the allocation will be deferred to the first 
            call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" />. 
            </summary>
            <param name="windowBits">The <c>windowBits</c> parameter is the base two logarithm of the maximum window size (the size of the history buffer). 
            It should be in the range <c>8..15</c> for this version of the library. The default value is 15 if <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit(System.Int32)" /> is used instead.
            If a compressed stream with a larger window size is given as input, <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" /> will return with the error code 
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR" /> instead of trying to allocate a larger window.</param>
            <returns>
            inflateInit returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK" /> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_MEM_ERROR" /> if there was not enough memory,
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR" /> if a parameter is invalid (such as a negative memLevel). <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.msg" /> is set to null 
            if there is no error message. <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateInit(System.Int32)" /> does not perform any decompression apart from reading the ZLib header 
            if present: this will be done by <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" />. (So <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in" /> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in" /> may be modified, 
            but <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out" /> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out" /> are unchanged.)
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)">
            <summary>
            <para>This method decompresses as much data as possible, and stops when the input buffer (<see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in" />) becomes empty or 
            the output buffer (<see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out" />) becomes full. It may some introduce some output latency (reading input without producing any output) 
            except when forced to flush. </para>
            <para>The detailed semantics are as follows. <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" /> performs one or both of the following actions: </para>
            <para>
            <list type="bullet">
            <item>Decompress more input starting at <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in" /> and update <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in" /> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in" /> 
            accordingly. If not all input can be processed (because there is not enough room in the output buffer), <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in" /> is updated and 
            processing will resume at this point for the next call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" />. </item>
            <item>Provide more output starting at <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out" /> and update <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out" /> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out" /> 
            accordingly. <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" /> provides as much output as possible, until there is no more input data or no more space in 
            the output buffer (see below about the <paramref name="flush" /> parameter).</item>
            </list>
            </para>
            </summary>
            <param name="flush"><see cref="T:ComponentAce.Compression.Libs.ZLib.FlushStrategy">Flush strategy</see> to use.</param>
            <remarks>
            <para>Before the call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" />, the application should ensure that at least one of the actions is possible, by providing 
            more input and/or consuming more output, and updating the next_* and avail_* values accordingly. The application can consume the uncompressed 
            output when it wants, for example when the output buffer is full (<c>avail_out == 0</c>), or after each call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" />. 
            If <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" /> returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK" /> and with zero <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out" />, it must be called again 
            after making room in the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out">output buffer</see> because there might be more output pending. </para>
            <para>If the parameter <paramref name="flush" /> is set to <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_SYNC_FLUSH" />, <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" /> flushes 
            as much output as possible to the output buffer. The flushing behavior of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" /> is not specified for values of 
            the <paramref name="flush" /> parameter other than <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_SYNC_FLUSH" /> and <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH" />, 
            but the current implementation actually flushes as much output as possible anyway. </para>
            <para><see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" /> should normally be called until it returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END" /> or an error. 
            However if all decompression is to be performed in a single step (a single call of inflate), the parameter <paramref name="flush" /> 
            should be set to <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH" />. In this case all pending input is processed and all pending output is flushed; 
            <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out" /> must be large enough to hold all the uncompressed data. (The size of the uncompressed data may have been 
            saved by the compressor for this purpose.) The next operation on this stream must be <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateEnd" /> to deallocate the decompression 
            state. The use of <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH" /> is never required, but can be used to inform <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" /> that a faster 
            routine may be used for the single <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" /> call. </para>
            <para>If a preset dictionary is needed at this point (see <see cref = "M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSetDictionary(System.Byte[],System.Int32)" />), <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" /> sets strm-adler 
            to the adler32 checksum of the dictionary chosen by the compressor and returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_NEED_DICT" />; otherwise it 
            sets strm->adler to the adler32 checksum of all output produced so far (that is, <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.total_out" /> bytes) and returns
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK" />, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END" /> or an error code as described below. At the end of the stream, 
            <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" />) checks that its computed adler32 checksum is equal to that saved by the compressor and returns
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END" /> only if the checksum is correct.</para>
            </remarks>
            <returns>
            <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" /> returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK" /> if some progress has been made (more input processed or more output produced), 
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END" /> if the end of the compressed data has been reached and all uncompressed output has been produced, 
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_NEED_DICT" /> if a preset dictionary is needed at this point, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR" /> if 
            the input data was corrupted (input stream not conforming to the ZLib format or incorrect adler32 checksum), 
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR" /> if the stream structure was inconsistent (for example if <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in" /> or 
            <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out" /> was <c>null</c>), <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_MEM_ERROR" /> if there was not enough memory, 
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_BUF_ERROR" /> if no progress is possible or if there was not enough room in the output buffer 
            when <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH" /> is used. In the <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR" /> case, the application 
            may then call <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSync" /> to look for a good compression block.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateEnd">
            <summary>
            All dynamically allocated data structures for this stream are freed. This function discards any unprocessed input and does not flush any 
            pending output.
            </summary>
            <returns>
            inflateEnd returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK" /> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR" /> 
            if the stream state was inconsistent. In the error case, msg may be set but then points to a static string (which must not be deallocated).
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSync">
            <summary>
            Skips invalid compressed data until a full flush point (see the description of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)">deflate with Z_FULL_FLUSH</see>) can be found, 
            or until all available input is skipped. No output is provided.
            </summary>
            <returns>
            <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSync" /> returns <seec ref="ZLibResultCode.Z_OK" /> if a full flush point has been found, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_BUF_ERROR" />
            if no more input was provided, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR" /> if no flush point has been found, or 
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR" /> if the stream structure was inconsistent. In the success case, the application may save the current 
            current value of <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.total_in" /> which indicates where valid compressed data was found. In the error case, the application may repeatedly 
            call <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSync" />, providing more input each time, until success or end of the input data.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSetDictionary(System.Byte[],System.Int32)">
            <summary>
            Initializes the decompression dictionary from the given uncompressed byte sequence. This function must be called immediately after a call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" /> if this call returned <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_NEED_DICT" />. The dictionary chosen by the compressor can be determined from the Adler32 value returned by this call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" />. The compressor and decompresser must use exactly the same dictionary.
            </summary>
            <param name="dictionary">A byte array - a dictionary.</param>
            <param name="dictLength">The length of the dictionary.</param>
            <returns>
            inflateSetDictionary returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK" /> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR" /> if a parameter is invalid (such as <c>null</c> dictionary) or the stream state is inconsistent, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR" /> if the given dictionary doesn't match the expected one (incorrect Adler32 value). inflateSetDictionary does not perform any decompression: this will be done by subsequent calls of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" />.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.DeflateInit(System.Int32)">
            <summary>
            Initializes the internal stream state for compression. 
            </summary>
            <param name="level">An integer value from 0 to 9 indicating the desired compression level.</param>
            <returns>
            DeflateInit returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK" /> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_MEM_ERROR" /> if there was not enough memory, 
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR" /> if level is not a valid compression level. <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.msg" /> is set to <c>null</c> if there is 
            no error message. <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.DeflateInit(System.Int32)" /> does not perform any compression: this will be done by <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" />.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.DeflateInit(System.Int32,System.Int32)">
            <summary>
            Initializes the internal stream state for compression. 
            </summary>
            <param name="level">An integer value from 0 to 9 indicating the desired compression level.</param>
            <param name="bits"> The windowBits parameter is the base two logarithm of the window size (the size of the history buffer). It should be in the 
            range 8..15 for this version of the library. Larger values of this parameter result in better compression at the expense of memory usage. 
            The default value is 15 if DeflateInit is used instead.</param>
            <returns>
            DeflateInit returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK" /> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_MEM_ERROR" /> if there was not enough memory,
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR" /> if level is not a valid compression level. <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.msg" /> is set to <c>null</c> if there 
            is no error message. <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.DeflateInit(System.Int32,System.Int32)" /> does not perform any compression: this will be done by <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" />.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)">
            <summary>
            <para>Deflate compresses as much data as possible, and stops when the <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in">input buffer</see> becomes empty or the 
            <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out">output buffer</see> becomes full. It may introduce some output latency (reading input without producing any output) 
            except when forced to flush.</para>
            <para>The detailed semantics are as follows. deflate performs one or both of the following actions:
            <list type="bullet">
            <item>Compress more input starting at <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in" /> and update <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in" /> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in" /> accordingly. 
            If not all input can be processed (because there is not enough room in the output buffer), <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in" /> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in" /> 
            are updated and processing will resume at this point for the next call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" />. </item>
            <item>Provide more output starting at <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out" /> and update <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out" /> and <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out" /> accordingly. 
            This action is forced if the parameter flush is non zero. Forcing flush frequently degrades the compression ratio, so this parameter should 
            be set only when necessary (in interactive applications). Some output may be provided even if flush is not set.</item>
            </list>
            </para>
            </summary>
            <param name="flush">The <see cref="T:ComponentAce.Compression.Libs.ZLib.FlushStrategy">flush strategy</see> to use.</param>
            <remarks>
            <para>
            Before the call of <seec ref="deflate" />, the application should ensure that at least one of the actions is possible, by providing 
            more input and/or consuming more output, and updating <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in" /> or <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out" /> accordingly ; <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out" /> 
            should never be zero before the call. The application can consume the compressed output when it wants, for example when the output buffer is full
            (<c>avail_out == 0</c>), or after each call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" />. If <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" /> returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK" /> 
            and with zero <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out" />, it must be called again after making room in the output buffer because there might be more output pending. 
            </para>
            <para>
            If the parameter <paramref name="flush"/> is set to <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_SYNC_FLUSH" />, all pending output is flushed to the 
            <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out">output buffer</see> and the output is aligned on a byte boundary, so that the decompressor can get all input 
            data available so far. (In particular <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in" /> is zero after the call if enough output space has been provided before the call.) 
            Flushing may degrade compression for some compression algorithms and so it should be used only when necessary. 
            </para>
            <para>
            If flush is set to <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FULL_FLUSH" />, all output is flushed as with <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_SYNC_FLUSH" />, 
            and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if 
            random access is desired. Using <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FULL_FLUSH" /> too often can seriously degrade the compression.
            </para>
            </remarks>
            <returns>
            <para>
            If deflate returns with <c><see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out" /> == 0</c>, this function must be called again with the same value of the flush
            parameter and more output space (updated <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out" />), until the flush is complete (<see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" /> returns with
            non-zero <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out" />). 
            </para>
            <para>
            If the parameter <paramref name="flush"/> is set to <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH" />, pending input is processed, pending 
            output is flushed and deflate returns with <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END" /> if there was enough output space ; 
            if deflate returns with <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK" />, this function must be called again with <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH" /> 
            and more output space (updated <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out" />) but no more input data, until it returns with <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END" /> 
            or an error. After deflate has returned <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END" />, the only possible operation on the stream is
            <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateEnd" />. </para>
            <para>
            <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH" /> can be used immediately after <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.DeflateInit(System.Int32)" /> if all the compression is to be 
            done in a single step. In this case, avail_out must be at least 0.1% larger than avail_in plus 12 bytes. If deflate does not return 
            Z_STREAM_END, then it must be called again as described above. 
            </para>
            <para>
            <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" /> sets strm-> adler to the adler32 checksum of all input read so far (that is, <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.total_in" /> bytes). 
            </para>
            <para>
            <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" /> may update data_type if it can make a good guess about the input data type (<see cref="T:ComponentAce.Compression.Libs.ZLib.BlockType">Z_ASCII or Z_BINARY</see>).
            In doubt, the data is considered binary. This field is only for information purposes and does not affect the compression algorithm in any manner. 
            </para>
            <para>
            <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" /> returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK" /> if some progress has been made (more input processed or more output produced), 
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_END" /> if all input has been consumed and all output has been produced (only when flush is set to
            <see cref="F:ComponentAce.Compression.Libs.ZLib.FlushStrategy.Z_FINISH" />), <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR" /> if the stream state was inconsistent (for example if 
            <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in" /> or <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out" /> was <c>null</c>), <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_BUF_ERROR" /> if no progress is possible
            (for example <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_in" /> or <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out" /> was zero).
            </para>
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateEnd">
            <summary>
            All dynamically allocated data structures for this stream are freed. This function discards any unprocessed input and does not flush any pending 
            output.
            </summary>
            <returns>
            deflateEnd returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK" /> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR" /> if the stream state was inconsistent, 
            <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_DATA_ERROR" /> if the stream was freed prematurely (some input or output was discarded). In the error case, 
            <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.msg" /> may be set but then points to a static string (which must not be deallocated).
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateParams(System.Int32,ComponentAce.Compression.Libs.ZLib.CompressionStrategy)">
            <summary>
            Dynamically update the compression level and compression strategy. The interpretation of level is as in <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.DeflateInit(System.Int32)"/>. 
            This can be used to switch between compression and straight copy of the input data, or to switch to a different kind of input data 
            requiring a different strategy. If the compression level is changed, the input available so far is compressed with the old level 
            (and may be flushed); the new level will take effect only at the next call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" />
            </summary>
            <param name="level">An integer value indicating the desired compression level.</param>
            <param name="strategy">A <see cref="T:ComponentAce.Compression.Libs.ZLib.FlushStrategy">flush strategy</see> to use.</param>
            <remarks>
            Before the call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateParams(System.Int32,ComponentAce.Compression.Libs.ZLib.CompressionStrategy)" />, the stream state must be set as for a call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" />, since the 
            currently available input may have to be compressed and flushed. In particular, <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out" /> must be non-zero.
            </remarks>
            <returns>
            deflateParams returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK" /> if success, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR" /> if the source stream 
            state was inconsistent or if a parameter was invalid, <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_BUF_ERROR" /> if <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.avail_out" /> was zero.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateSetDictionary(System.Byte[],System.Int32)">
            <summary>
            Initializes the compression dictionary from the given byte sequence without producing any compressed output. This function must be called 
            immediately after <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.DeflateInit(System.Int32)" />, before any call of <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" />. The compressor and decompressor must use 
            exactly the same dictionary (see <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.inflateSetDictionary(System.Byte[],System.Int32)" />).
            </summary>
            <param name="dictionary">A byte array - a dictionary.</param>
            <param name="dictLength">The length of the dictionary byte array</param>
            <remarks>
            <para>
            The dictionary should consist of strings (byte sequences) that are likely to be encountered later in the data to be compressed, 
            with the most commonly used strings preferably put towards the end of the dictionary. Using a dictionary is most useful when the data 
            to be compressed is short and can be predicted with good accuracy; the data can then be compressed better than with the default empty dictionary.
            </para>
            <para>Depending on the size of the compression data structures selected by <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.DeflateInit(System.Int32)" />, a part of the dictionary may 
            in effect be discarded, for example if the dictionary is larger than the window size in <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" />. Thus the strings most likely 
            to be useful should be put at the end of the dictionary, not at the front.</para>
            <para>Upon return of this function, adler is set to the Adler32 value of the dictionary; the decompresser may later use this value to determine 
            which dictionary has been used by the compressor. (The Adler32 value applies to the whole dictionary even if only a subset of the dictionary 
            is actually used by the compressor.)</para>
            </remarks>
            <returns>
            deflateSetDictionary returns <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_OK" /> if success, or <see cref="F:ComponentAce.Compression.Libs.ZLib.ZLibResultCode.Z_STREAM_ERROR" /> if a parameter 
            is invalid (such as <c>null</c> dictionary) or the stream state is inconsistent (for example if <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" /> has already been 
            called for this stream or if the compression method is bsort). <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflateSetDictionary(System.Byte[],System.Int32)" /> does not perform any compression: 
            this will be done by <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" />.
            </returns>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.FlushPending">
            <summary>
            Flush as much pending output as possible. All <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" /> output goes through this function so some applications may wish to 
            modify it to avoid allocating a large <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_out" /> buffer and copying into it.
            </summary>
            <seealso cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.ReadBuf(System.Byte[],System.Int32,System.Int32)" />
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.ReadBuf(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a new buffer from the current input stream, update the adler32 and total number of bytes read.  All <see cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.deflate(ComponentAce.Compression.Libs.ZLib.FlushStrategy)" /> input goes 
            through this function so some applications may wish to modify it to avoid allocating a large <see cref="P:ComponentAce.Compression.Libs.ZLib.ZStream.next_in" /> buffer and copying from it.
            </summary>
            <seealso cref="M:ComponentAce.Compression.Libs.ZLib.ZStream.FlushPending"/>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStream.free">
            <summary>
            Frees all inner <see cref="T:ComponentAce.Compression.Libs.ZLib.ZStream" /> buffers.
            </summary>
        </member>
        <member name="T:ComponentAce.Compression.Libs.ZLib.ZStreamException">
            <summary>
            Exceptions that occur in ZStream
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStreamException.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:ComponentAce.Compression.Libs.ZLib.ZStreamException.#ctor(System.String)">
            <summary>
            Constructor which takes one parameter - an error message
            </summary>
        </member>
    </members>
</doc>
